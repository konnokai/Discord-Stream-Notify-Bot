# Story 2.3: 其他平台爬蟲邏輯遷移

## Status
Draft

## Story
**As a** 系統架構師,
**I want** 將 Twitch、Twitter、TwitCasting 爬蟲邏輯遷移至 Crawler 服務並建立統一的平台監控介面,
**so that** 實現所有平台監控功能的獨立部署和統一管理

## Acceptance Criteria

1. [ ] 建立 `PlatformMonitors/TwitchMonitor.cs` 包含 Twitch API 和 EventSub
   - Twitch API 調用邏輯
   - EventSub 訂閱管理
   - 直播狀態監控
   - Webhook 事件處理
2. [ ] 建立 `PlatformMonitors/TwitterMonitor.cs` 包含 Twitter Spaces 監控
   - Twitter Spaces API 邏輯
   - Cookie 認證管理
   - Spaces 狀態檢測
   - 不穩定連接處理
3. [ ] 建立 `PlatformMonitors/TwitCastingMonitor.cs` 包含 TwitCasting API
   - TwitCasting API 整合
   - 直播狀態輪詢
   - 使用者資訊管理
   - API 限制處理
4. [ ] 實作統一的平台監控介面 `IPlatformMonitor`
   - 定義通用的監控方法
   - 狀態報告標準化
   - 啟動和停止介面
   - 錯誤處理標準化
5. [ ] 建立各平台的錯誤處理和 Rate Limiting 機制
   - 平台特定的錯誤處理
   - Rate Limit 監控和延遲
   - 連接失敗重試邏輯
   - 異常狀況恢復機制
6. [ ] 整合所有平台到統一的監控系統
   - 平台監控器註冊
   - 平行執行多個平台監控
   - 統一的事件廣播格式
   - 監控狀態報告

## Tasks / Subtasks

- [ ] Task 1: 建立統一平台監控介面 (AC: 4)
  - [ ] 建立 `Interfaces/IPlatformMonitor.cs` 統一監控介面
  - [ ] 定義 `Models/PlatformMonitorStatus.cs` 狀態報告模型
  - [ ] 定義 `Models/StreamStatusChangedEventArgs.cs` 事件參數
  - [ ] 建立 `Models/StreamData.cs` 統一串流資料模型
  - [ ] 建立 `Services/PlatformMonitorManager.cs` 平台管理服務

- [ ] Task 2: 實作 Twitch 平台監控器 (AC: 1)
  - [ ] 從 `SharedService/Twitch/TwitchService.cs` 遷移 Twitch API 邏輯
  - [ ] 建立 `PlatformMonitors/TwitchMonitor.cs` 實作 `IPlatformMonitor`
  - [ ] 遷移 Twitch EventSub 訂閱管理功能
  - [ ] 遷移 Twitch Webhook 處理邏輯到 `WebhookHandlers/TwitchWebhookHandler.cs`
  - [ ] 實作 Twitch 直播狀態檢測和變化追蹤
  - [ ] 建立 Twitch API 錯誤處理和重試機制

- [ ] Task 3: 實作 Twitter Spaces 平台監控器 (AC: 2)
  - [ ] 從 `SharedService/Twitter/TwitterSpacesService.cs` 遷移核心邏輯
  - [ ] 建立 `PlatformMonitors/TwitterMonitor.cs` 實作 `IPlatformMonitor`
  - [ ] 遷移 Twitter Cookie 認證管理機制
  - [ ] 實作 Twitter Spaces 狀態輪詢和檢測
  - [ ] 建立 Twitter API 不穩定連接處理策略
  - [ ] 實作 Twitter Spaces 事件廣播機制

- [ ] Task 4: 實作 TwitCasting 平台監控器 (AC: 3)
  - [ ] 從 `SharedService/Twitcasting/TwitcastingService.cs` 遷移 API 邏輯
  - [ ] 建立 `PlatformMonitors/TwitCastingMonitor.cs` 實作 `IPlatformMonitor`
  - [ ] 遷移 TwitCasting API 整合和認證邏輯
  - [ ] 實作 TwitCasting 直播狀態輪詢機制
  - [ ] 建立 TwitCasting 使用者資訊管理
  - [ ] 實作 TwitCasting API 限制處理機制

- [ ] Task 5: 建立統一錯誤處理系統 (AC: 5)
  - [ ] 建立 `Services/ErrorHandlingService.cs` 統一錯誤管理
  - [ ] 實作平台特定的錯誤分類和處理策略
  - [ ] 建立 Rate Limiting 監控和延遲機制
  - [ ] 實作指數退避重試算法
  - [ ] 建立異常狀況恢復和通知機制
  - [ ] 實作詳細錯誤日誌記錄和統計

- [ ] Task 6: 整合平台監控管理系統 (AC: 6)
  - [ ] 實作 `Services/PlatformMonitorManager.cs` 統一管理器
  - [ ] 建立平台監控器動態註冊機制
  - [ ] 實作多平台並行監控執行
  - [ ] 建立統一事件廣播和 Redis PubSub 整合
  - [ ] 實作監控狀態收集和報告機制
  - [ ] 建立監控器生命週期管理

- [ ] Task 7: 實作事件廣播和追蹤管理整合 (AC: 6)
  - [ ] 建立 `Services/StreamEventBroadcaster.cs` 事件廣播服務
  - [ ] 實作跨平台統一事件格式轉換
  - [ ] 整合 Redis PubSub 事件發送機制，支援錄影工具相容格式：
    - YouTube: `youtube.record` (videoId) - 直播開始錄影請求
    - Twitch: `twitch.record` (userLogin) - Twitch 直播錄影請求
    - 服務檢測: `youtube.test` - Crawler 啟動時檢測錄影工具是否運行
  - [ ] 建立批量事件合併和優化（Discord Shard 用）
  - [ ] 實作與外部錄影工具的完全相容性
  - [ ] 建立事件發送失敗重試和錯誤處理

- [ ] Task 8: 建立監控器配置和初始化 (AC: 4, 6)
  - [ ] 擴展配置模型支援各平台設定
  - [ ] 建立監控器依賴注入配置
  - [ ] 實作監控器啟動順序管理
  - [ ] 建立監控器健康檢查機制
  - [ ] 實作監控器熱重載配置支援
  - [ ] 建立監控器狀態持久化機制

- [ ] Task 9: 整合測試和驗證 (AC: 1-6)
  - [ ] 建立各平台監控器單元測試
  - [ ] 建立統一介面整合測試
  - [ ] 建立錯誤處理機制測試
  - [ ] 建立並行監控效能測試
  - [ ] 建立事件廣播端到端測試
  - [ ] 建立監控器狀態管理測試

## Dev Notes

### 現有平台服務架構分析

**[Source: SharedService/ 目錄結構]**

現有的平台服務都位於 `SharedService/` 目錄下，每個平台都有獨立的服務類別：
- `SharedService/Twitch/TwitchService.cs` - Twitch 直播監控和 EventSub 處理
- `SharedService/Twitter/TwitterSpacesService.cs` - Twitter Spaces 監控
- `SharedService/Twitcasting/TwitcastingService.cs` - TwitCasting 直播監控

這些服務需要完整遷移到 Crawler 服務中，並實作統一的監控介面。

### Twitch 服務遷移策略
**[Source: SharedService/Twitch/TwitchService.cs]**

Twitch 服務包含以下核心功能需要遷移：
- **Twitch API 整合**：使用 TwitchLib 和原生 HTTP API 調用
- **EventSub 訂閱管理**：管理 Webhook 訂閱和事件處理
- **直播狀態監控**：定時檢查直播狀態變化
- **Webhook 處理**：接收和解析 Twitch EventSub 事件

遷移重點：
```csharp
// 現有的 TwitchService 核心方法需要遷移
public class TwitchMonitor : IPlatformMonitor
{
    public string PlatformName => "Twitch";
    
    // 遷移現有的 EventSub 訂閱邏輯
    public async Task ManageEventSubSubscription(string userId, bool subscribe)
    {
        // 從原有 TwitchService 遷移訂閱邏輯
    }
    
    // 遷移現有的直播狀態檢測
    public async Task CheckStreamStatus(List<string> userIds)
    {
        // 從原有 TwitchService 遷移狀態檢測邏輯
    }
}
```

### Twitter Spaces 服務遷移策略
**[Source: SharedService/Twitter/TwitterSpacesService.cs]**

Twitter Spaces 服務具有特殊的認證機制和不穩定的 API：
- **Cookie 認證**：使用 Twitter 網頁版 Cookie 進行認證
- **非官方 API**：使用逆向工程的 GraphQL API
- **不穩定連接**：需要處理頻繁的連接失敗和認證問題
- **Spaces 狀態檢測**：輪詢檢查 Spaces 開始/結束狀態

特殊考慮事項：
```csharp
// Twitter Cookie 認證管理
public class TwitterMonitor : IPlatformMonitor
{
    private readonly CookieContainer _cookieContainer;
    private readonly HttpClient _httpClient;
    
    // 處理 Twitter 特有的不穩定連接問題
    public async Task<bool> ValidateAuthenticationAsync()
    {
        // 檢查 Cookie 有效性
        // 處理 401/403 錯誤
        // 實作認證重新整理機制
    }
    
    // Twitter GraphQL API 調用
    public async Task<TwitterSpacesData> GetSpacesDataAsync(string spaceId)
    {
        // 使用 Cookie 認證的 GraphQL 請求
        // 處理 Rate Limiting 和錯誤重試
    }
}
```

### TwitCasting 服務遷移策略
**[Source: SharedService/Twitcasting/TwitcastingService.cs]**

TwitCasting 服務相對簡單但有 API 限制：
- **官方 API**：使用官方 REST API
- **輪詢機制**：定時檢查直播狀態
- **API 限制**：需要處理 Rate Limiting
- **使用者管理**：管理追蹤的使用者清單

遷移實作：
```csharp
public class TwitCastingMonitor : IPlatformMonitor
{
    // 遷移現有的 API 調用邏輯
    public async Task<TwitCastingStreamData> GetLiveStatusAsync(string userId)
    {
        // 從原有服務遷移 API 調用
        // 處理 Rate Limiting
        // 實作錯誤重試機制
    }
    
    // 批量狀態檢查
    public async Task CheckMultipleStreamsAsync(List<string> userIds)
    {
        // 批量處理減少 API 調用
        // 實作並行處理和錯誤隔離
    }
}
```

### 統一平台監控介面設計
**[Source: docs/brownfield-architecture.md#平台監控介面設計]**

需要建立統一的 `IPlatformMonitor` 介面來標準化所有平台的監控行為：

```csharp
public interface IPlatformMonitor
{
    string PlatformName { get; }
    Task StartAsync(CancellationToken cancellationToken);
    Task StopAsync(CancellationToken cancellationToken);
    Task<PlatformMonitorStatus> GetStatusAsync();
    event EventHandler<StreamStatusChangedEventArgs> StreamStatusChanged;
}

public class PlatformMonitorStatus
{
    public string PlatformName { get; set; }
    public bool IsHealthy { get; set; }
    public int MonitoredStreamsCount { get; set; }
    public DateTime LastUpdateTime { get; set; }
    public Dictionary<string, object> Metadata { get; set; }
}

public class StreamStatusChangedEventArgs : EventArgs
{
    public StreamData StreamData { get; set; }
    public bool IsOnline { get; set; }
    public DateTime Timestamp { get; set; }
}
```

### 錯誤處理和重試機制標準化
**[Source: docs/brownfield-architecture.md#技術債務-外部 API 整合脆弱性]**

各平台都有不同的錯誤處理需求：

```csharp
public class PlatformErrorHandler
{
    // 平台特定的錯誤處理策略
    public async Task<T> ExecuteWithRetryAsync<T>(
        string platform, 
        Func<Task<T>> operation,
        RetryPolicy policy = null)
    {
        policy ??= GetDefaultRetryPolicy(platform);
        
        for (int attempt = 0; attempt < policy.MaxAttempts; attempt++)
        {
            try
            {
                return await operation();
            }
            catch (Exception ex) when (ShouldRetry(platform, ex, attempt))
            {
                await Task.Delay(policy.GetDelay(attempt));
            }
        }
        throw new MaxRetryAttemptsExceededException(platform);
    }
    
    private bool ShouldRetry(string platform, Exception ex, int attempt)
    {
        return platform switch
        {
            "Twitch" => IsRetryableTwitchError(ex),
            "Twitter" => IsRetryableTwitterError(ex),
            "TwitCasting" => IsRetryableTwitCastingError(ex),
            _ => false
        };
    }
}
```

### 事件廣播系統設計
**[Source: docs/brownfield-architecture.md#Redis PubSub 頻道 + StreamRecordTools/Command/Subscribe.cs]**

需要建立統一的事件廣播機制，與現有錄影工具保持完全相容。根據錄影工具程式碼分析，需要支援以下事件：

**錄影工具訂閱的事件頻道**：
- `youtube.record` - 新直播錄影請求
- `youtube.rerecord` - 重新錄影請求
- `youtube.unarchived` - 已刪檔直播通知
- `youtube.memberonly` - 已轉會限直播通知
- `twitch.record` - Twitch 錄影請求
- `streamTools.removeById` - 容器清理請求

```csharp
public class StreamEventBroadcaster
{
    // 統一的事件廣播格式
    public async Task BroadcastStreamStatusChange(StreamData stream, bool isOnline)
    {
        // 發送給 Discord Shard 的批量事件
        var batchEvent = isOnline ? "streams.online" : "streams.offline";
        await _redis.PublishAsync(batchEvent, new List<StreamData> { stream });
        
        // 發送給錄影工具的錄影請求事件（保持相容）
        if (isOnline)
        {
            switch (stream.Platform.ToLower())
            {
                case "youtube":
                    // 錄影工具期望的格式：videoId
                    await _redis.PublishAsync("youtube.record", stream.VideoId);
                    break;
                case "twitch":
                    // 錄影工具期望的格式：userLogin
                    await _redis.PublishAsync("twitch.record", stream.UserLogin);
                    break;
                // TwitCasting 和 Twitter 目前錄影工具不支援，保留擴展性
            }
        }
    }
    
    // Crawler 服務啟動時檢測錄影工具是否存在
    public async Task<bool> CheckRecordingToolAvailability()
    {
        try
        {
            // 發送測試事件，檢查是否有訂閱者（類似 RightNowRecordStream 指令的檢查方式）
            var subscriberCount = await _redis.PublishAsync("youtube.test", "");
            if (subscriberCount > 0)
            {
                _logger.LogInfo("錄影工具已檢測到，可以正常錄影");
                return true;
            }
            else
            {
                _logger.LogWarn("未檢測到錄影工具，請確認錄影工具是否已啟動");
                return false;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "檢測錄影工具時發生錯誤");
            return false;
        }
    }
}
```

### 監控器管理系統架構
**[Source: docs/brownfield-architecture.md#Crawler 服務架構]**

需要建立統一的監控器管理系統：

```csharp
public class PlatformMonitorManager : IHostedService
{
    private readonly List<IPlatformMonitor> _monitors;
    private readonly IServiceProvider _serviceProvider;
    
    public async Task StartAsync(CancellationToken cancellationToken)
    {
        // 註冊所有平台監控器
        _monitors.Add(_serviceProvider.GetRequiredService<TwitchMonitor>());
        _monitors.Add(_serviceProvider.GetRequiredService<TwitterMonitor>());
        _monitors.Add(_serviceProvider.GetRequiredService<TwitCastingMonitor>());
        
        // 並行啟動所有監控器
        var startTasks = _monitors.Select(m => StartMonitorAsync(m, cancellationToken));
        await Task.WhenAll(startTasks);
        
        Log.Info($"Started {_monitors.Count} platform monitors");
    }
    
    private async Task StartMonitorAsync(IPlatformMonitor monitor, CancellationToken cancellationToken)
    {
        try
        {
            monitor.StreamStatusChanged += OnStreamStatusChanged;
            await monitor.StartAsync(cancellationToken);
            Log.Info($"Started {monitor.PlatformName} monitor");
        }
        catch (Exception ex)
        {
            Log.Error(ex, $"Failed to start {monitor.PlatformName} monitor");
            // 不拋出例外，允許其他監控器繼續啟動
        }
    }
    
    private async void OnStreamStatusChanged(object sender, StreamStatusChangedEventArgs e)
    {
        // 統一處理所有平台的狀態變化事件
        await _eventBroadcaster.BroadcastStreamStatusChange(e.StreamData, e.IsOnline);
    }
}
```

### 配置管理擴展
**[Source: docs/brownfield-architecture.md#配置管理簡化]**

需要擴展現有配置結構支援各平台設定：

```csharp
public class PlatformConfig
{
    public TwitchConfig Twitch { get; set; } = new();
    public TwitterConfig Twitter { get; set; } = new();
    public TwitCastingConfig TwitCasting { get; set; } = new();
}

public class TwitchConfig
{
    public string ClientId { get; set; }
    public string ClientSecret { get; set; }
    public string WebhookSecret { get; set; }
    public string CallbackUrl { get; set; }
    public int MonitorIntervalSeconds { get; set; } = 300;
    public int MaxRetryAttempts { get; set; } = 3;
}

public class TwitterConfig
{
    public string CookieAuth { get; set; }
    public string CsrfToken { get; set; }
    public string AuthToken { get; set; }
    public int MonitorIntervalSeconds { get; set; } = 60;
    public int MaxRetryAttempts { get; set; } = 5;
    public bool EnableStabilityCheck { get; set; } = true;
}

public class TwitCastingConfig
{
    public string ClientId { get; set; }
    public string ClientSecret { get; set; }
    public string AccessToken { get; set; }
    public int MonitorIntervalSeconds { get; set; } = 180;
    public int MaxRetryAttempts { get; set; } = 3;
    public int RateLimitDelayMs { get; set; } = 1000;
}
```

### 資料庫整合保持不變
**[Source: docs/brownfield-architecture.md#資料庫架構保持不變]**

繼續使用現有的資料庫結構和 Entity Framework 配置：
- 重用 `DataBase/MainDbContext.cs` 和相關 Table 定義
- 繼續使用 `TwitchSpider`, `TwitterSpacesSpider`, `TwitCastingSpider` 等資料表
- 保持現有的追蹤管理和直播資料儲存機制

### 錄影工具整合要求
**[Source: https://github.com/konnokai/StreamRecordTools/blob/master/StreamRecordTools/Command/Subscribe.cs]**

Crawler 服務必須與現有的 StreamRecordTools 錄影工具保持完全相容。錄影工具訂閱以下 Redis 事件：

**必須支援的事件格式**:
```csharp
// YouTube 事件 - 錄影工具期望的格式
await _redis.PublishAsync("youtube.record", videoId);           // 開始錄影
await _redis.PublishAsync("youtube.test", "");                  // 服務啟動時檢測錄影工具是否存在

// Twitch 事件 - 錄影工具期望的格式  
await _redis.PublishAsync("twitch.record", userLogin);          // Twitch 錄影
```

**事件觸發時機**:
- `youtube.record`: 當檢測到 YouTube 直播開始時
- `youtube.test`: Crawler 服務啟動時發送，用於檢測錄影工具是否運行
- `twitch.record`: 當檢測到 Twitch 直播開始時

**不需要實作的事件**:
- `youtube.unarchived`: 錄影工具自己處理直播刪除檢測
- `youtube.memberonly`: 錄影工具自己處理會限狀態檢測  
- `youtube.rerecord`: 手動重新錄影指令，非自動觸發
- `youtube.test.cookie`: 手動測試用，非自動觸發

**重要相容性要求**:
1. 事件格式必須完全匹配錄影工具期望的格式
2. YouTube 事件傳送 videoId（字串格式）
3. Twitch 事件傳送 userLogin（使用者名稱，字串格式）
4. `youtube.test` 用於 Crawler 啟動時檢測錄影工具是否運行，提醒使用者是否需要啟動錄影工具
5. 不需實作 `youtube.unarchived`, `youtube.memberonly`, `youtube.rerecord` 等事件（由錄影工具或手動觸發）

### Testing

**單元測試要求**:
- 各平台監控器獨立測試 (Mock 外部 API)
- 統一介面實作測試
- 錯誤處理和重試機制測試
- 事件廣播邏輯測試

**整合測試要求**:
- 多平台並行監控測試
- Redis PubSub 事件流程測試
- 資料庫操作整合測試
- Webhook 處理端到端測試

**效能測試要求**:
- 大量串流監控效能測試
- 並行 API 調用效能測試
- 記憶體使用和洩漏檢測
- Rate Limiting 處理效能測試

**手動測試驗證**:
1. 驗證各平台監控器正常運作
2. 測試錯誤處理和重試機制
3. 驗證事件廣播和 Discord 通知
4. 測試監控器生命週期管理
5. 驗證與外部錄影工具的相容性：
   - 測試 `youtube.record` 事件觸發錄影工具
   - 測試 `twitch.record` 事件觸發錄影工具
   - 測試 Crawler 啟動時 `youtube.test` 錄影工具檢測功能
   - 驗證事件格式符合錄影工具期望
6. 測試配置熱重載和動態管理
7. 驗證 Redis PubSub 事件與錄影工具的端到端整合

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | Story 初始建立 | Scrum Master |

## Dev Agent Record

_此區段由開發代理在實作期間填寫_

### Agent Model Used

_待開發代理填寫_

### Debug Log References

_待開發代理填寫_

### Completion Notes List

_待開發代理填寫_

### File List

_待開發代理填寫_

## QA Results

_此區段由 QA 代理在完成故事實作的 QA 審查後填寫_
