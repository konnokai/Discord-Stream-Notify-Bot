# Story 3.4: tmux 部署腳本和監控介面

## Status
Draft

## Story
**As a** 系統管理員,
**I want** Coordinator 服務提供完整的 tmux 部署腳本和即時監控介面,
**so that** 我可以用簡單的命令啟動/停止整個系統，並透過 console 介面即時監控所有服務狀態和日誌輸出

## Acceptance Criteria

1. 建立 `start-services.sh` tmux session 管理腳本，能自動啟動 Coordinator 並管理所有服務
2. 建立 `stop-services.sh` 優雅關閉腳本，確保所有服務正確停止並清理資源
3. 實作 console 監控介面顯示所有服務狀態，包含即時日誌和服務健康狀態
4. 建立結構化日誌輸出（JSON 格式），支援不同日誌等級和結構化資料
5. 實作 Discord Webhook 異常通知機制，在服務故障時自動發送通知

## Tasks / Subtasks

- [ ] 建立 tmux 部署腳本系統 (AC: 1, 2)
  - [ ] 建立 `Scripts/start-services.sh` 啟動腳本
  - [ ] 建立 `Scripts/stop-services.sh` 停止腳本
  - [ ] 實作 tmux session 管理和視窗配置
  - [ ] 建立服務啟動狀態檢查和錯誤處理

- [ ] 實作 Console 監控介面 (AC: 3)
  - [ ] 建立 `Services/ConsoleMonitorService.cs` 監控服務
  - [ ] 實作即時服務狀態顯示面板
  - [ ] 建立分頁式日誌檢視器（各服務獨立頁面）
  - [ ] 實作互動式命令介面（重啟服務、查看詳細狀態）

- [ ] 建立結構化日誌系統 (AC: 4)
  - [ ] 實作 `Logging/StructuredLogger.cs` JSON 格式日誌
  - [ ] 建立統一的日誌事件模型和分類
  - [ ] 整合 Microsoft.Extensions.Logging 標準化日誌
  - [ ] 實作日誌檔案輪轉和大小管理

- [ ] 實作 Discord Webhook 通知系統 (AC: 5)
  - [ ] 建立 `Notifications/DiscordNotificationService.cs` 通知服務
  - [ ] 實作服務故障、重啟和恢復的 Webhook 通知
  - [ ] 建立通知模板和嚴重性等級過濾
  - [ ] 支援通知去重和頻率限制機制

## Dev Notes

### Previous Story Insights
基於 Story 3.1-3.3 已建立的 gRPC 服務、進程管理和 YAML 配置系統，本 Story 將提供完整的部署自動化和運行時監控能力。

### tmux 部署架構設計
基於簡化運維和單機部署的原則，設計 tmux 會話管理系統：

**tmux Session 架構：**
```bash
# Session: discord-stream-bot
# ├── Window 0: coordinator    # Coordinator 服務
# ├── Window 1: crawler        # Crawler 服務  
# ├── Window 2: shard-0        # Discord Shard 0
# ├── Window 3: shard-1        # Discord Shard 1
# ├── Window N: shard-N-1      # Discord Shard N-1
# └── Window 99: monitor       # 監控介面
```

**啟動腳本設計 (start-services.sh)：**
```bash
#!/bin/bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
SESSION_NAME="discord-stream-bot"

# 顏色定義
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# 檢查依賴環境
check_dependencies() {
    log "檢查系統依賴..."
    
    # 檢查 tmux
    if ! command -v tmux &> /dev/null; then
        error "tmux 未安裝，請先安裝: sudo apt install tmux"
        exit 1
    fi
    
    # 檢查 .NET
    if ! command -v dotnet &> /dev/null; then
        error ".NET 8.0 未安裝"
        exit 1
    fi
    
    # 檢查配置檔案
    if [[ ! -f "$PROJECT_ROOT/coord.yml" ]]; then
        error "coord.yml 配置檔案不存在"
        exit 1
    fi
    
    success "依賴檢查完成"
}

# 啟動 Coordinator 並等待就緒
start_coordinator() {
    log "啟動 Coordinator 服務..."
    
    # 建立新的 tmux session，第一個 window 為 coordinator
    tmux new-session -d -s "$SESSION_NAME" -n "coordinator" \
        "cd '$PROJECT_ROOT' && dotnet run --project StreamNotifyBot.Coordinator"
    
    # 等待 Coordinator gRPC 服務就緒
    local max_wait=30
    local wait_time=0
    
    while [[ $wait_time -lt $max_wait ]]; do
        if curl -sf http://localhost:6110/health &> /dev/null; then
            success "Coordinator 服務已啟動"
            return 0
        fi
        
        sleep 1
        ((wait_time++))
        echo -n "."
    done
    
    error "Coordinator 服務啟動超時"
    return 1
}

# 建立監控視窗
create_monitor_window() {
    log "建立監控視窗..."
    
    tmux new-window -t "$SESSION_NAME" -n "monitor" \
        "cd '$PROJECT_ROOT' && dotnet run --project StreamNotifyBot.Coordinator -- --monitor-mode"
    
    success "監控視窗已建立"
}

# 主函數
main() {
    log "開始啟動 Discord Stream Bot 服務..."
    
    # 檢查是否已有 session 運行
    if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        log "檢測到現有 session，正在停止..."
        bash "$SCRIPT_DIR/stop-services.sh"
        sleep 2
    fi
    
    check_dependencies
    start_coordinator
    
    # 等待 Coordinator 自動啟動其他服務
    log "等待 Coordinator 自動啟動所有服務..."
    sleep 10
    
    create_monitor_window
    
    success "所有服務已啟動完成"
    log "使用以下命令管理服務："
    log "  檢視服務: tmux attach-session -t $SESSION_NAME"
    log "  停止服務: bash $SCRIPT_DIR/stop-services.sh"
    log "  監控介面: tmux select-window -t ${SESSION_NAME}:monitor"
}

main "$@"
```

[Source: docs/brownfield-prd.md#NFR6 部署簡化]

**停止腳本設計 (stop-services.sh)：**
```bash
#!/bin/bash
set -euo pipefail

SESSION_NAME="discord-stream-bot"
GRACEFUL_TIMEOUT=30

log() {
    echo -e "\033[0;34m[$(date +'%Y-%m-%d %H:%M:%S')]\033[0m $1"
}

error() {
    echo -e "\033[0;31m[ERROR]\033[0m $1" >&2
}

success() {
    echo -e "\033[0;32m[SUCCESS]\033[0m $1"
}

# 優雅停止服務
graceful_shutdown() {
    log "開始優雅停止 Discord Stream Bot 服務..."
    
    if ! tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        log "未發現運行中的 session"
        return 0
    fi
    
    # 發送 SIGTERM 給 Coordinator（會自動停止其他服務）
    log "發送停止信號給 Coordinator..."
    tmux send-keys -t "${SESSION_NAME}:coordinator" C-c
    
    # 等待服務優雅關閉
    local wait_time=0
    while [[ $wait_time -lt $GRACEFUL_TIMEOUT ]]; do
        if ! curl -sf http://localhost:6110/health &> /dev/null; then
            success "服務已優雅停止"
            break
        fi
        sleep 1
        ((wait_time++))
        echo -n "."
    done
    
    # 強制停止 tmux session
    log "清理 tmux session..."
    tmux kill-session -t "$SESSION_NAME" 2>/dev/null || true
    
    success "所有服務已停止"
}

main() {
    graceful_shutdown
}

main "$@"
```

[Source: docs/brownfield-prd.md#部署約束]

### Console 監控介面設計
**即時監控面板實作：**
```csharp
public class ConsoleMonitorService : BackgroundService
{
    private readonly ProcessManager _processManager;
    private readonly ILogger<ConsoleMonitorService> _logger;
    private readonly CancellationTokenSource _cancellationTokenSource = new();
    
    public ConsoleMonitorService(
        ProcessManager processManager, 
        ILogger<ConsoleMonitorService> logger)
    {
        _processManager = processManager;
        _logger = logger;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        Console.Clear();
        Console.CursorVisible = false;
        
        try
        {
            await RunMonitorLoopAsync(stoppingToken);
        }
        finally
        {
            Console.CursorVisible = true;
        }
    }
    
    private async Task RunMonitorLoopAsync(CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                await UpdateDisplayAsync();
                await ProcessUserInputAsync();
                await Task.Delay(1000, cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "監控介面更新失敗");
                await Task.Delay(5000, cancellationToken);
            }
        }
    }
    
    private async Task UpdateDisplayAsync()
    {
        Console.SetCursorPosition(0, 0);
        
        // 標題區域
        Console.ForegroundColor = ConsoleColor.Cyan;
        Console.WriteLine("═══════════════════════════════════════════════════");
        Console.WriteLine("     Discord Stream Bot - 服務監控介面");
        Console.WriteLine($"     更新時間: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        Console.WriteLine("═══════════════════════════════════════════════════");
        Console.ResetColor();
        Console.WriteLine();
        
        // 服務狀態區域
        var services = await _processManager.GetAllServicesAsync();
        Console.ForegroundColor = ConsoleColor.White;
        Console.WriteLine("【服務狀態】");
        Console.WriteLine($"{"服務名稱",-20} {"狀態",-12} {"運行時間",-15} {"資源使用",-15}");
        Console.WriteLine(new string('─', 80));
        
        foreach (var service in services.OrderBy(s => s.Type).ThenBy(s => s.ShardId))
        {
            var statusColor = service.Status switch
            {
                ServiceStatus.Running => ConsoleColor.Green,
                ServiceStatus.Starting => ConsoleColor.Yellow,
                ServiceStatus.Failed => ConsoleColor.Red,
                _ => ConsoleColor.Gray
            };
            
            Console.ForegroundColor = statusColor;
            var serviceName = service.ShardId >= 0 
                ? $"Shard-{service.ShardId}" 
                : service.Type.ToString();
                
            var uptime = service.Status == ServiceStatus.Running 
                ? FormatUptime(service.Uptime) 
                : "N/A";
                
            var resource = service.Status == ServiceStatus.Running 
                ? $"{service.MemoryUsageMB:N0}MB" 
                : "N/A";
                
            Console.WriteLine($"{serviceName,-20} {service.Status,-12} {uptime,-15} {resource,-15}");
        }
        
        Console.ResetColor();
        Console.WriteLine();
        
        // 最近日誌區域
        DisplayRecentLogs();
        
        // 命令提示區域
        Console.ForegroundColor = ConsoleColor.DarkGray;
        Console.WriteLine(new string('─', 80));
        Console.WriteLine("命令: [R]重啟服務 [L]檢視日誌 [S]服務詳細 [Q]退出");
        Console.ResetColor();
    }
    
    private void DisplayRecentLogs()
    {
        Console.ForegroundColor = ConsoleColor.White;
        Console.WriteLine("【最近日誌】");
        Console.WriteLine(new string('─', 80));
        
        var recentLogs = GetRecentStructuredLogs(10);
        foreach (var log in recentLogs)
        {
            var levelColor = log.Level switch
            {
                LogLevel.Error => ConsoleColor.Red,
                LogLevel.Warning => ConsoleColor.Yellow,
                LogLevel.Information => ConsoleColor.White,
                _ => ConsoleColor.Gray
            };
            
            Console.ForegroundColor = levelColor;
            Console.WriteLine($"{log.Timestamp:HH:mm:ss} [{log.Level}] {log.ServiceName}: {log.Message}");
        }
        
        Console.ResetColor();
        Console.WriteLine();
    }
}

public class StructuredLogEntry
{
    public DateTime Timestamp { get; set; }
    public LogLevel Level { get; set; }
    public string ServiceName { get; set; } = string.Empty;
    public string Message { get; set; } = string.Empty;
    public Dictionary<string, object> Properties { get; set; } = new();
}
```

**互動式命令處理：**
```csharp
private async Task ProcessUserInputAsync()
{
    if (!Console.KeyAvailable) return;
    
    var key = Console.ReadKey(true);
    
    switch (key.Key)
    {
        case ConsoleKey.R:
            await HandleRestartCommandAsync();
            break;
        case ConsoleKey.L:
            await HandleViewLogsCommandAsync();
            break;
        case ConsoleKey.S:
            await HandleServiceDetailsCommandAsync();
            break;
        case ConsoleKey.Q:
            _cancellationTokenSource.Cancel();
            break;
    }
}

private async Task HandleRestartCommandAsync()
{
    Console.SetCursorPosition(0, Console.WindowHeight - 3);
    Console.Write("請輸入要重啟的服務名稱 (crawler/shard-0/shard-1...): ");
    
    Console.CursorVisible = true;
    var serviceName = Console.ReadLine();
    Console.CursorVisible = false;
    
    if (!string.IsNullOrWhiteSpace(serviceName))
    {
        try
        {
            await _processManager.RestartServiceAsync(serviceName.Trim());
            ShowMessage($"服務 {serviceName} 重啟指令已發送", ConsoleColor.Green);
        }
        catch (Exception ex)
        {
            ShowMessage($"重啟失敗: {ex.Message}", ConsoleColor.Red);
        }
    }
    
    // 清理輸入區域
    Console.SetCursorPosition(0, Console.WindowHeight - 3);
    Console.Write(new string(' ', Console.WindowWidth));
}
```

[Source: docs/brownfield-prd.md#NFR5 日誌和監控]

### 結構化日誌系統
**JSON 格式日誌實作：**
```csharp
public class StructuredLogger : ILogger
{
    private readonly string _categoryName;
    private readonly JsonSerializerOptions _jsonOptions;
    
    public StructuredLogger(string categoryName)
    {
        _categoryName = categoryName;
        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = false
        };
    }
    
    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, 
        Exception? exception, Func<TState, Exception?, string> formatter)
    {
        if (!IsEnabled(logLevel)) return;
        
        var logEntry = new
        {
            Timestamp = DateTime.UtcNow,
            Level = logLevel.ToString(),
            Category = _categoryName,
            EventId = eventId.Id,
            Message = formatter(state, exception),
            Exception = exception?.ToString(),
            Properties = ExtractProperties(state),
            ServiceInfo = GetServiceContext()
        };
        
        var json = JsonSerializer.Serialize(logEntry, _jsonOptions);
        
        // 輸出到 console（有顏色）和檔案（純文字）
        WriteToConsole(logLevel, json);
        WriteToFile(json);
    }
    
    private void WriteToConsole(LogLevel logLevel, string json)
    {
        var color = logLevel switch
        {
            LogLevel.Error => ConsoleColor.Red,
            LogLevel.Warning => ConsoleColor.Yellow,
            LogLevel.Information => ConsoleColor.White,
            LogLevel.Debug => ConsoleColor.Gray,
            _ => ConsoleColor.DarkGray
        };
        
        var originalColor = Console.ForegroundColor;
        Console.ForegroundColor = color;
        Console.WriteLine(json);
        Console.ForegroundColor = originalColor;
    }
    
    private void WriteToFile(string json)
    {
        var logFile = Path.Combine("logs", $"app-{DateTime.Now:yyyyMMdd}.log");
        Directory.CreateDirectory(Path.GetDirectoryName(logFile)!);
        
        // 使用非阻塞寫入，避免影響應用效能
        _ = Task.Run(async () =>
        {
            try
            {
                await File.AppendAllTextAsync(logFile, json + Environment.NewLine);
            }
            catch
            {
                // 靜默處理檔案寫入錯誤，避免影響主要功能
            }
        });
    }
    
    private Dictionary<string, object> ExtractProperties<TState>(TState state)
    {
        var properties = new Dictionary<string, object>();
        
        if (state is IEnumerable<KeyValuePair<string, object>> enumerable)
        {
            foreach (var kvp in enumerable)
            {
                if (kvp.Key != "{OriginalFormat}")
                {
                    properties[kvp.Key] = kvp.Value;
                }
            }
        }
        
        return properties;
    }
    
    private object GetServiceContext()
    {
        return new
        {
            ServiceName = Environment.GetEnvironmentVariable("SERVICE_NAME") ?? "Coordinator",
            ShardId = Environment.GetEnvironmentVariable("SHARD_ID"),
            ProcessId = Environment.ProcessId,
            MachineName = Environment.MachineName,
            Version = Assembly.GetEntryAssembly()?.GetName().Version?.ToString()
        };
    }
}
```

**日誌提供者整合：**
```csharp
public class StructuredLoggerProvider : ILoggerProvider
{
    private readonly ConcurrentDictionary<string, StructuredLogger> _loggers = new();
    
    public ILogger CreateLogger(string categoryName)
    {
        return _loggers.GetOrAdd(categoryName, name => new StructuredLogger(name));
    }
    
    public void Dispose()
    {
        _loggers.Clear();
    }
}

// Program.cs 整合
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureLogging(logging =>
        {
            logging.ClearProviders();
            logging.AddProvider(new StructuredLoggerProvider());
        })
        .ConfigureServices((context, services) =>
        {
            services.AddHostedService<ConsoleMonitorService>();
        });
```

[Source: docs/brownfield-prd.md#NFR5 日誌和監控]

### Discord Webhook 通知系統
**通知服務實作：**
```csharp
public class DiscordNotificationService
{
    private readonly IHttpClientFactory _httpClientFactory;
    private readonly IConfiguration _configuration;
    private readonly ILogger<DiscordNotificationService> _logger;
    private readonly SemaphoreSlim _rateLimitSemaphore = new(1, 1);
    private DateTime _lastNotification = DateTime.MinValue;
    
    public DiscordNotificationService(
        IHttpClientFactory httpClientFactory,
        IConfiguration configuration,
        ILogger<DiscordNotificationService> logger)
    {
        _httpClientFactory = httpClientFactory;
        _configuration = configuration;
        _logger = logger;
    }
    
    public async Task SendServiceFailureNotificationAsync(string serviceName, string reason)
    {
        if (!ShouldSendNotification(NotificationSeverity.Error)) return;
        
        var embed = new
        {
            title = "🚨 服務故障警報",
            description = $"服務 **{serviceName}** 發生故障",
            color = 15158332, // 紅色
            fields = new[]
            {
                new { name = "服務名稱", value = serviceName, inline = true },
                new { name = "故障原因", value = reason, inline = true },
                new { name = "發生時間", value = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"), inline = true },
                new { name = "主機名稱", value = Environment.MachineName, inline = true }
            },
            timestamp = DateTime.UtcNow
        };
        
        await SendDiscordWebhookAsync(embed);
    }
    
    public async Task SendServiceRecoveryNotificationAsync(string serviceName, TimeSpan downtime)
    {
        if (!ShouldSendNotification(NotificationSeverity.Info)) return;
        
        var embed = new
        {
            title = "✅ 服務恢復通知",
            description = $"服務 **{serviceName}** 已恢復正常",
            color = 5763719, // 綠色
            fields = new[]
            {
                new { name = "服務名稱", value = serviceName, inline = true },
                new { name = "停機時間", value = FormatDuration(downtime), inline = true },
                new { name = "恢復時間", value = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"), inline = true }
            },
            timestamp = DateTime.UtcNow
        };
        
        await SendDiscordWebhookAsync(embed);
    }
    
    private async Task SendDiscordWebhookAsync(object embed)
    {
        var webhookUrl = _configuration["Discord:WebhookUrl"];
        if (string.IsNullOrEmpty(webhookUrl)) return;
        
        await _rateLimitSemaphore.WaitAsync();
        try
        {
            var payload = new
            {
                username = "Discord Stream Bot Monitor",
                avatar_url = "https://cdn.discordapp.com/embed/avatars/0.png",
                embeds = new[] { embed }
            };
            
            var client = _httpClientFactory.CreateClient();
            client.Timeout = TimeSpan.FromSeconds(10);
            
            var json = JsonSerializer.Serialize(payload);
            var content = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await client.PostAsync(webhookUrl, content);
            
            if (response.IsSuccessStatusCode)
            {
                _logger.LogInformation("Discord 通知發送成功");
            }
            else
            {
                _logger.LogWarning("Discord 通知發送失敗: {StatusCode}", response.StatusCode);
            }
            
            _lastNotification = DateTime.Now;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "發送 Discord 通知時發生例外");
        }
        finally
        {
            _rateLimitSemaphore.Release();
        }
    }
    
    private bool ShouldSendNotification(NotificationSeverity severity)
    {
        // 防止通知洪水：同一嚴重程度通知間隔至少 5 分鐘
        var minInterval = severity switch
        {
            NotificationSeverity.Error => TimeSpan.FromMinutes(5),
            NotificationSeverity.Warning => TimeSpan.FromMinutes(10),
            NotificationSeverity.Info => TimeSpan.FromMinutes(15),
            _ => TimeSpan.FromHours(1)
        };
        
        return DateTime.Now - _lastNotification >= minInterval;
    }
}

public enum NotificationSeverity
{
    Error,
    Warning,
    Info
}
```

[Source: docs/brownfield-prd.md#實作異常通知機制（Discord Webhook）]

### Project Structure
本 Story 將在現有 Coordinator 專案中新增部署和監控功能：
```
StreamNotifyBot.Coordinator/
├── Scripts/
│   ├── start-services.sh           # 本 Story 新增
│   ├── stop-services.sh            # 本 Story 新增
│   └── install-deps.sh             # 本 Story 新增
├── Services/
│   ├── ConsoleMonitorService.cs    # 本 Story 新增
│   └── DiscordNotificationService.cs # 本 Story 新增
├── Logging/
│   ├── StructuredLogger.cs         # 本 Story 新增
│   ├── StructuredLoggerProvider.cs # 本 Story 新增
│   └── LogEntry.cs                 # 本 Story 新增
├── Models/
│   └── NotificationModels.cs       # 本 Story 新增
└── logs/                           # 本 Story 新增（日誌目錄）
```

[Source: docs/brownfield-architecture.md#實際技術堆疊]

### 設定檔整合
**擴展 appsettings.json：**
```json
{
  "MonitoringConsole": {
    "RefreshIntervalMs": 1000,
    "MaxLogLines": 100,
    "EnableInteractiveMode": true,
    "LogFile": "logs/app-{Date}.log"
  },
  "Discord": {
    "WebhookUrl": "{{DISCORD_WEBHOOK_URL}}",
    "NotificationSettings": {
      "EnableFailureAlerts": true,
      "EnableRecoveryAlerts": true,
      "RateLimitMinutes": 5,
      "MinSeverityLevel": "Warning"
    }
  },
  "Tmux": {
    "SessionName": "discord-stream-bot",
    "SessionTimeout": 300,
    "GracefulShutdownTimeout": 30
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "StreamNotifyBot.Coordinator.Logging": "Debug"
    },
    "StructuredLogging": {
      "EnableConsoleColors": true,
      "EnableFileLogging": true,
      "MaxLogFileSizeMB": 100,
      "RetainLogDays": 7
    }
  }
}
```

**coord.yml 監控設定擴展：**
```yaml
monitoring:
  recheckIntervalMs: 2000
  unresponsiveSec: 30
  maxRestartAttempts: 3
  restartDelayMs: 5000
  autoRestart: true
  
  # 新增監控設定
  console:
    refreshIntervalMs: 1000
    maxDisplayLogs: 50
    enableColors: true
    interactiveMode: true
    
  notifications:
    discord:
      webhookUrl: "{{DISCORD_WEBHOOK_URL}}"
      enableFailureAlerts: true
      enableRecoveryAlerts: true
      rateLimitMinutes: 5
      
  logging:
    structured: true
    outputFormat: "json"
    logLevel: "Information"
    fileRotation:
      maxSizeMB: 100
      retainDays: 7
```

[Source: docs/brownfield-architecture.md#統一配置管理]

### 部署流程整合
**完整部署流程：**
```bash
# 1. 環境準備
./Scripts/install-deps.sh

# 2. 設定配置
cp coord.example.yml coord.yml
# 編輯 coord.yml 設定環境變數

# 3. 啟動服務
./Scripts/start-services.sh

# 4. 檢視監控
tmux attach-session -t discord-stream-bot
tmux select-window -t discord-stream-bot:monitor

# 5. 停止服務（需要時）
./Scripts/stop-services.sh
```

**健康檢查整合：**
```csharp
public class SystemHealthService
{
    public async Task<HealthCheckResult> CheckSystemHealthAsync()
    {
        var results = new List<HealthCheckItem>();
        
        // 檢查各服務狀態
        var services = await _processManager.GetAllServicesAsync();
        foreach (var service in services)
        {
            results.Add(new HealthCheckItem
            {
                Name = service.Name,
                Status = service.Status == ServiceStatus.Running ? "Healthy" : "Unhealthy",
                LastCheck = DateTime.UtcNow,
                Details = new { service.Uptime, service.MemoryUsageMB }
            });
        }
        
        // 檢查 tmux session
        var sessionExists = await CheckTmuxSessionAsync();
        results.Add(new HealthCheckItem
        {
            Name = "Tmux Session",
            Status = sessionExists ? "Healthy" : "Unhealthy",
            LastCheck = DateTime.UtcNow
        });
        
        // 檢查磁碟空間
        var diskSpace = await CheckDiskSpaceAsync();
        results.Add(new HealthCheckItem
        {
            Name = "Disk Space",
            Status = diskSpace > 1024 ? "Healthy" : "Warning", // 1GB 最小空間
            LastCheck = DateTime.UtcNow,
            Details = new { AvailableSpaceMB = diskSpace }
        });
        
        return new HealthCheckResult
        {
            OverallStatus = results.All(r => r.Status == "Healthy") ? "Healthy" : "Degraded",
            Checks = results,
            Timestamp = DateTime.UtcNow
        };
    }
}
```

[Source: docs/brownfield-prd.md#部署順序]

### Testing

**單元測試需求：**
- tmux 腳本功能測試（模擬環境）
- Console 監控介面邏輯測試
- 結構化日誌格式和輸出測試
- Discord Webhook 通知機制測試

**整合測試需求：**
- 完整部署流程測試
- 服務故障場景下的通知機制測試
- 長時間運行的監控穩定性測試

**測試工具和框架：**
- xUnit 作為測試框架
- Moq 用於模擬 HTTP 和檔案系統操作
- Microsoft.AspNetCore.TestHost 用於 Web API 測試
- 自訂 TmuxTestHelper 類別模擬 tmux 操作

**測試腳本範例：**
```bash
#!/bin/bash
# test-deployment.sh

# 模擬部署測試
TEST_SESSION="test-discord-bot"

cleanup() {
    tmux kill-session -t "$TEST_SESSION" 2>/dev/null || true
}

trap cleanup EXIT

# 測試啟動腳本
echo "測試服務啟動..."
SESSION_NAME="$TEST_SESSION" ./Scripts/start-services.sh

# 等待服務啟動
sleep 30

# 檢查服務狀態
if curl -sf http://localhost:6110/health; then
    echo "✅ 健康檢查通過"
else
    echo "❌ 健康檢查失敗"
    exit 1
fi

# 測試停止腳本
echo "測試服務停止..."
SESSION_NAME="$TEST_SESSION" ./Scripts/stop-services.sh

echo "✅ 部署測試完成"
```

[Source: docs/brownfield-architecture.md#測試策略]

### 效能和資源考量
- **監控頻率**: 1 秒更新間隔，平衡即時性和 CPU 使用
- **日誌檔案管理**: 自動輪轉，預設保留 7 天，單檔最大 100MB
- **記憶體使用**: 監控介面限制最多顯示 100 行日誌，避免記憶體洩漏
- **通知頻率限制**: 同等級通知間隔至少 5 分鐘，防止通知洪水
- **tmux 會話管理**: 自動檢查重複會話，避免資源浪費

[Source: docs/brownfield-prd.md#NFR4 資源使用效率]

### 安全和穩定性考量
- **腳本權限控制**: 執行腳本需要適當的檔案權限
- **Discord Webhook 保護**: Webhook URL 透過環境變數配置，不寫入日誌
- **優雅關閉**: 確保服務停止時正確清理資源和保存狀態
- **錯誤恢復**: 監控介面崩潰時不影響主要服務運行
- **日誌安全**: 敏感資訊（Token、密碼）自動遮罩處理

[Source: docs/brownfield-prd.md#技術約束和限制]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | 建立 tmux 部署腳本和監控介面故事 | Scrum Master |
