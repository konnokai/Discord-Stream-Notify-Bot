# Story 3.4: tmux éƒ¨ç½²è…³æœ¬å’Œç›£æ§ä»‹é¢

## Status
Draft

## Story
**As a** ç³»çµ±ç®¡ç†å“¡,
**I want** Coordinator æœå‹™æä¾›å®Œæ•´çš„ tmux éƒ¨ç½²è…³æœ¬å’Œå³æ™‚ç›£æ§ä»‹é¢,
**so that** æˆ‘å¯ä»¥ç”¨ç°¡å–®çš„å‘½ä»¤å•Ÿå‹•/åœæ­¢æ•´å€‹ç³»çµ±ï¼Œä¸¦é€é console ä»‹é¢å³æ™‚ç›£æ§æ‰€æœ‰æœå‹™ç‹€æ…‹å’Œæ—¥èªŒè¼¸å‡º

## Acceptance Criteria

1. å»ºç«‹ `start-services.sh` tmux session ç®¡ç†è…³æœ¬ï¼Œèƒ½è‡ªå‹•å•Ÿå‹• Coordinator ä¸¦ç®¡ç†æ‰€æœ‰æœå‹™
2. å»ºç«‹ `stop-services.sh` å„ªé›…é—œé–‰è…³æœ¬ï¼Œç¢ºä¿æ‰€æœ‰æœå‹™æ­£ç¢ºåœæ­¢ä¸¦æ¸…ç†è³‡æº
3. å¯¦ä½œ console ç›£æ§ä»‹é¢é¡¯ç¤ºæ‰€æœ‰æœå‹™ç‹€æ…‹ï¼ŒåŒ…å«å³æ™‚æ—¥èªŒå’Œæœå‹™å¥åº·ç‹€æ…‹
4. å»ºç«‹çµæ§‹åŒ–æ—¥èªŒè¼¸å‡ºï¼ˆJSON æ ¼å¼ï¼‰ï¼Œæ”¯æ´ä¸åŒæ—¥èªŒç­‰ç´šå’Œçµæ§‹åŒ–è³‡æ–™
5. å¯¦ä½œ Discord Webhook ç•°å¸¸é€šçŸ¥æ©Ÿåˆ¶ï¼Œåœ¨æœå‹™æ•…éšœæ™‚è‡ªå‹•ç™¼é€é€šçŸ¥

## Tasks / Subtasks

- [ ] å»ºç«‹ tmux éƒ¨ç½²è…³æœ¬ç³»çµ± (AC: 1, 2)
  - [ ] å»ºç«‹ `Scripts/start-services.sh` å•Ÿå‹•è…³æœ¬
  - [ ] å»ºç«‹ `Scripts/stop-services.sh` åœæ­¢è…³æœ¬
  - [ ] å¯¦ä½œ tmux session ç®¡ç†å’Œè¦–çª—é…ç½®
  - [ ] å»ºç«‹æœå‹™å•Ÿå‹•ç‹€æ…‹æª¢æŸ¥å’ŒéŒ¯èª¤è™•ç†

- [ ] å¯¦ä½œ Console ç›£æ§ä»‹é¢ (AC: 3)
  - [ ] å»ºç«‹ `Services/ConsoleMonitorService.cs` ç›£æ§æœå‹™
  - [ ] å¯¦ä½œå³æ™‚æœå‹™ç‹€æ…‹é¡¯ç¤ºé¢æ¿
  - [ ] å»ºç«‹åˆ†é å¼æ—¥èªŒæª¢è¦–å™¨ï¼ˆå„æœå‹™ç¨ç«‹é é¢ï¼‰
  - [ ] å¯¦ä½œäº’å‹•å¼å‘½ä»¤ä»‹é¢ï¼ˆé‡å•Ÿæœå‹™ã€æŸ¥çœ‹è©³ç´°ç‹€æ…‹ï¼‰

- [ ] å»ºç«‹çµæ§‹åŒ–æ—¥èªŒç³»çµ± (AC: 4)
  - [ ] å¯¦ä½œ `Logging/StructuredLogger.cs` JSON æ ¼å¼æ—¥èªŒ
  - [ ] å»ºç«‹çµ±ä¸€çš„æ—¥èªŒäº‹ä»¶æ¨¡å‹å’Œåˆ†é¡
  - [ ] æ•´åˆ Microsoft.Extensions.Logging æ¨™æº–åŒ–æ—¥èªŒ
  - [ ] å¯¦ä½œæ—¥èªŒæª”æ¡ˆè¼ªè½‰å’Œå¤§å°ç®¡ç†

- [ ] å¯¦ä½œ Discord Webhook é€šçŸ¥ç³»çµ± (AC: 5)
  - [ ] å»ºç«‹ `Notifications/DiscordNotificationService.cs` é€šçŸ¥æœå‹™
  - [ ] å¯¦ä½œæœå‹™æ•…éšœã€é‡å•Ÿå’Œæ¢å¾©çš„ Webhook é€šçŸ¥
  - [ ] å»ºç«‹é€šçŸ¥æ¨¡æ¿å’Œåš´é‡æ€§ç­‰ç´šéæ¿¾
  - [ ] æ”¯æ´é€šçŸ¥å»é‡å’Œé »ç‡é™åˆ¶æ©Ÿåˆ¶

## Dev Notes

### Previous Story Insights
åŸºæ–¼ Story 3.1-3.3 å·²å»ºç«‹çš„ gRPC æœå‹™ã€é€²ç¨‹ç®¡ç†å’Œ YAML é…ç½®ç³»çµ±ï¼Œæœ¬ Story å°‡æä¾›å®Œæ•´çš„éƒ¨ç½²è‡ªå‹•åŒ–å’Œé‹è¡Œæ™‚ç›£æ§èƒ½åŠ›ã€‚

### tmux éƒ¨ç½²æ¶æ§‹è¨­è¨ˆ
åŸºæ–¼ç°¡åŒ–é‹ç¶­å’Œå–®æ©Ÿéƒ¨ç½²çš„åŸå‰‡ï¼Œè¨­è¨ˆ tmux æœƒè©±ç®¡ç†ç³»çµ±ï¼š

**tmux Session æ¶æ§‹ï¼š**
```bash
# Session: discord-stream-bot
# â”œâ”€â”€ Window 0: coordinator    # Coordinator æœå‹™
# â”œâ”€â”€ Window 1: crawler        # Crawler æœå‹™  
# â”œâ”€â”€ Window 2: shard-0        # Discord Shard 0
# â”œâ”€â”€ Window 3: shard-1        # Discord Shard 1
# â”œâ”€â”€ Window N: shard-N-1      # Discord Shard N-1
# â””â”€â”€ Window 99: monitor       # ç›£æ§ä»‹é¢
```

**å•Ÿå‹•è…³æœ¬è¨­è¨ˆ (start-services.sh)ï¼š**
```bash
#!/bin/bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
SESSION_NAME="discord-stream-bot"

# é¡è‰²å®šç¾©
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# æª¢æŸ¥ä¾è³´ç’°å¢ƒ
check_dependencies() {
    log "æª¢æŸ¥ç³»çµ±ä¾è³´..."
    
    # æª¢æŸ¥ tmux
    if ! command -v tmux &> /dev/null; then
        error "tmux æœªå®‰è£ï¼Œè«‹å…ˆå®‰è£: sudo apt install tmux"
        exit 1
    fi
    
    # æª¢æŸ¥ .NET
    if ! command -v dotnet &> /dev/null; then
        error ".NET 8.0 æœªå®‰è£"
        exit 1
    fi
    
    # æª¢æŸ¥é…ç½®æª”æ¡ˆ
    if [[ ! -f "$PROJECT_ROOT/coord.yml" ]]; then
        error "coord.yml é…ç½®æª”æ¡ˆä¸å­˜åœ¨"
        exit 1
    fi
    
    success "ä¾è³´æª¢æŸ¥å®Œæˆ"
}

# å•Ÿå‹• Coordinator ä¸¦ç­‰å¾…å°±ç·’
start_coordinator() {
    log "å•Ÿå‹• Coordinator æœå‹™..."
    
    # å»ºç«‹æ–°çš„ tmux sessionï¼Œç¬¬ä¸€å€‹ window ç‚º coordinator
    tmux new-session -d -s "$SESSION_NAME" -n "coordinator" \
        "cd '$PROJECT_ROOT' && dotnet run --project StreamNotifyBot.Coordinator"
    
    # ç­‰å¾… Coordinator gRPC æœå‹™å°±ç·’
    local max_wait=30
    local wait_time=0
    
    while [[ $wait_time -lt $max_wait ]]; do
        if curl -sf http://localhost:6110/health &> /dev/null; then
            success "Coordinator æœå‹™å·²å•Ÿå‹•"
            return 0
        fi
        
        sleep 1
        ((wait_time++))
        echo -n "."
    done
    
    error "Coordinator æœå‹™å•Ÿå‹•è¶…æ™‚"
    return 1
}

# å»ºç«‹ç›£æ§è¦–çª—
create_monitor_window() {
    log "å»ºç«‹ç›£æ§è¦–çª—..."
    
    tmux new-window -t "$SESSION_NAME" -n "monitor" \
        "cd '$PROJECT_ROOT' && dotnet run --project StreamNotifyBot.Coordinator -- --monitor-mode"
    
    success "ç›£æ§è¦–çª—å·²å»ºç«‹"
}

# ä¸»å‡½æ•¸
main() {
    log "é–‹å§‹å•Ÿå‹• Discord Stream Bot æœå‹™..."
    
    # æª¢æŸ¥æ˜¯å¦å·²æœ‰ session é‹è¡Œ
    if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        log "æª¢æ¸¬åˆ°ç¾æœ‰ sessionï¼Œæ­£åœ¨åœæ­¢..."
        bash "$SCRIPT_DIR/stop-services.sh"
        sleep 2
    fi
    
    check_dependencies
    start_coordinator
    
    # ç­‰å¾… Coordinator è‡ªå‹•å•Ÿå‹•å…¶ä»–æœå‹™
    log "ç­‰å¾… Coordinator è‡ªå‹•å•Ÿå‹•æ‰€æœ‰æœå‹™..."
    sleep 10
    
    create_monitor_window
    
    success "æ‰€æœ‰æœå‹™å·²å•Ÿå‹•å®Œæˆ"
    log "ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ç®¡ç†æœå‹™ï¼š"
    log "  æª¢è¦–æœå‹™: tmux attach-session -t $SESSION_NAME"
    log "  åœæ­¢æœå‹™: bash $SCRIPT_DIR/stop-services.sh"
    log "  ç›£æ§ä»‹é¢: tmux select-window -t ${SESSION_NAME}:monitor"
}

main "$@"
```

[Source: docs/brownfield-prd.md#NFR6 éƒ¨ç½²ç°¡åŒ–]

**åœæ­¢è…³æœ¬è¨­è¨ˆ (stop-services.sh)ï¼š**
```bash
#!/bin/bash
set -euo pipefail

SESSION_NAME="discord-stream-bot"
GRACEFUL_TIMEOUT=30

log() {
    echo -e "\033[0;34m[$(date +'%Y-%m-%d %H:%M:%S')]\033[0m $1"
}

error() {
    echo -e "\033[0;31m[ERROR]\033[0m $1" >&2
}

success() {
    echo -e "\033[0;32m[SUCCESS]\033[0m $1"
}

# å„ªé›…åœæ­¢æœå‹™
graceful_shutdown() {
    log "é–‹å§‹å„ªé›…åœæ­¢ Discord Stream Bot æœå‹™..."
    
    if ! tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        log "æœªç™¼ç¾é‹è¡Œä¸­çš„ session"
        return 0
    fi
    
    # ç™¼é€ SIGTERM çµ¦ Coordinatorï¼ˆæœƒè‡ªå‹•åœæ­¢å…¶ä»–æœå‹™ï¼‰
    log "ç™¼é€åœæ­¢ä¿¡è™Ÿçµ¦ Coordinator..."
    tmux send-keys -t "${SESSION_NAME}:coordinator" C-c
    
    # ç­‰å¾…æœå‹™å„ªé›…é—œé–‰
    local wait_time=0
    while [[ $wait_time -lt $GRACEFUL_TIMEOUT ]]; do
        if ! curl -sf http://localhost:6110/health &> /dev/null; then
            success "æœå‹™å·²å„ªé›…åœæ­¢"
            break
        fi
        sleep 1
        ((wait_time++))
        echo -n "."
    done
    
    # å¼·åˆ¶åœæ­¢ tmux session
    log "æ¸…ç† tmux session..."
    tmux kill-session -t "$SESSION_NAME" 2>/dev/null || true
    
    success "æ‰€æœ‰æœå‹™å·²åœæ­¢"
}

main() {
    graceful_shutdown
}

main "$@"
```

[Source: docs/brownfield-prd.md#éƒ¨ç½²ç´„æŸ]

### Console ç›£æ§ä»‹é¢è¨­è¨ˆ
**å³æ™‚ç›£æ§é¢æ¿å¯¦ä½œï¼š**
```csharp
public class ConsoleMonitorService : BackgroundService
{
    private readonly ProcessManager _processManager;
    private readonly ILogger<ConsoleMonitorService> _logger;
    private readonly CancellationTokenSource _cancellationTokenSource = new();
    
    public ConsoleMonitorService(
        ProcessManager processManager, 
        ILogger<ConsoleMonitorService> logger)
    {
        _processManager = processManager;
        _logger = logger;
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        Console.Clear();
        Console.CursorVisible = false;
        
        try
        {
            await RunMonitorLoopAsync(stoppingToken);
        }
        finally
        {
            Console.CursorVisible = true;
        }
    }
    
    private async Task RunMonitorLoopAsync(CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                await UpdateDisplayAsync();
                await ProcessUserInputAsync();
                await Task.Delay(1000, cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "ç›£æ§ä»‹é¢æ›´æ–°å¤±æ•—");
                await Task.Delay(5000, cancellationToken);
            }
        }
    }
    
    private async Task UpdateDisplayAsync()
    {
        Console.SetCursorPosition(0, 0);
        
        // æ¨™é¡Œå€åŸŸ
        Console.ForegroundColor = ConsoleColor.Cyan;
        Console.WriteLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        Console.WriteLine("     Discord Stream Bot - æœå‹™ç›£æ§ä»‹é¢");
        Console.WriteLine($"     æ›´æ–°æ™‚é–“: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        Console.WriteLine("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        Console.ResetColor();
        Console.WriteLine();
        
        // æœå‹™ç‹€æ…‹å€åŸŸ
        var services = await _processManager.GetAllServicesAsync();
        Console.ForegroundColor = ConsoleColor.White;
        Console.WriteLine("ã€æœå‹™ç‹€æ…‹ã€‘");
        Console.WriteLine($"{"æœå‹™åç¨±",-20} {"ç‹€æ…‹",-12} {"é‹è¡Œæ™‚é–“",-15} {"è³‡æºä½¿ç”¨",-15}");
        Console.WriteLine(new string('â”€', 80));
        
        foreach (var service in services.OrderBy(s => s.Type).ThenBy(s => s.ShardId))
        {
            var statusColor = service.Status switch
            {
                ServiceStatus.Running => ConsoleColor.Green,
                ServiceStatus.Starting => ConsoleColor.Yellow,
                ServiceStatus.Failed => ConsoleColor.Red,
                _ => ConsoleColor.Gray
            };
            
            Console.ForegroundColor = statusColor;
            var serviceName = service.ShardId >= 0 
                ? $"Shard-{service.ShardId}" 
                : service.Type.ToString();
                
            var uptime = service.Status == ServiceStatus.Running 
                ? FormatUptime(service.Uptime) 
                : "N/A";
                
            var resource = service.Status == ServiceStatus.Running 
                ? $"{service.MemoryUsageMB:N0}MB" 
                : "N/A";
                
            Console.WriteLine($"{serviceName,-20} {service.Status,-12} {uptime,-15} {resource,-15}");
        }
        
        Console.ResetColor();
        Console.WriteLine();
        
        // æœ€è¿‘æ—¥èªŒå€åŸŸ
        DisplayRecentLogs();
        
        // å‘½ä»¤æç¤ºå€åŸŸ
        Console.ForegroundColor = ConsoleColor.DarkGray;
        Console.WriteLine(new string('â”€', 80));
        Console.WriteLine("å‘½ä»¤: [R]é‡å•Ÿæœå‹™ [L]æª¢è¦–æ—¥èªŒ [S]æœå‹™è©³ç´° [Q]é€€å‡º");
        Console.ResetColor();
    }
    
    private void DisplayRecentLogs()
    {
        Console.ForegroundColor = ConsoleColor.White;
        Console.WriteLine("ã€æœ€è¿‘æ—¥èªŒã€‘");
        Console.WriteLine(new string('â”€', 80));
        
        var recentLogs = GetRecentStructuredLogs(10);
        foreach (var log in recentLogs)
        {
            var levelColor = log.Level switch
            {
                LogLevel.Error => ConsoleColor.Red,
                LogLevel.Warning => ConsoleColor.Yellow,
                LogLevel.Information => ConsoleColor.White,
                _ => ConsoleColor.Gray
            };
            
            Console.ForegroundColor = levelColor;
            Console.WriteLine($"{log.Timestamp:HH:mm:ss} [{log.Level}] {log.ServiceName}: {log.Message}");
        }
        
        Console.ResetColor();
        Console.WriteLine();
    }
}

public class StructuredLogEntry
{
    public DateTime Timestamp { get; set; }
    public LogLevel Level { get; set; }
    public string ServiceName { get; set; } = string.Empty;
    public string Message { get; set; } = string.Empty;
    public Dictionary<string, object> Properties { get; set; } = new();
}
```

**äº’å‹•å¼å‘½ä»¤è™•ç†ï¼š**
```csharp
private async Task ProcessUserInputAsync()
{
    if (!Console.KeyAvailable) return;
    
    var key = Console.ReadKey(true);
    
    switch (key.Key)
    {
        case ConsoleKey.R:
            await HandleRestartCommandAsync();
            break;
        case ConsoleKey.L:
            await HandleViewLogsCommandAsync();
            break;
        case ConsoleKey.S:
            await HandleServiceDetailsCommandAsync();
            break;
        case ConsoleKey.Q:
            _cancellationTokenSource.Cancel();
            break;
    }
}

private async Task HandleRestartCommandAsync()
{
    Console.SetCursorPosition(0, Console.WindowHeight - 3);
    Console.Write("è«‹è¼¸å…¥è¦é‡å•Ÿçš„æœå‹™åç¨± (crawler/shard-0/shard-1...): ");
    
    Console.CursorVisible = true;
    var serviceName = Console.ReadLine();
    Console.CursorVisible = false;
    
    if (!string.IsNullOrWhiteSpace(serviceName))
    {
        try
        {
            await _processManager.RestartServiceAsync(serviceName.Trim());
            ShowMessage($"æœå‹™ {serviceName} é‡å•ŸæŒ‡ä»¤å·²ç™¼é€", ConsoleColor.Green);
        }
        catch (Exception ex)
        {
            ShowMessage($"é‡å•Ÿå¤±æ•—: {ex.Message}", ConsoleColor.Red);
        }
    }
    
    // æ¸…ç†è¼¸å…¥å€åŸŸ
    Console.SetCursorPosition(0, Console.WindowHeight - 3);
    Console.Write(new string(' ', Console.WindowWidth));
}
```

[Source: docs/brownfield-prd.md#NFR5 æ—¥èªŒå’Œç›£æ§]

### çµæ§‹åŒ–æ—¥èªŒç³»çµ±
**JSON æ ¼å¼æ—¥èªŒå¯¦ä½œï¼š**
```csharp
public class StructuredLogger : ILogger
{
    private readonly string _categoryName;
    private readonly JsonSerializerOptions _jsonOptions;
    
    public StructuredLogger(string categoryName)
    {
        _categoryName = categoryName;
        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = false
        };
    }
    
    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, 
        Exception? exception, Func<TState, Exception?, string> formatter)
    {
        if (!IsEnabled(logLevel)) return;
        
        var logEntry = new
        {
            Timestamp = DateTime.UtcNow,
            Level = logLevel.ToString(),
            Category = _categoryName,
            EventId = eventId.Id,
            Message = formatter(state, exception),
            Exception = exception?.ToString(),
            Properties = ExtractProperties(state),
            ServiceInfo = GetServiceContext()
        };
        
        var json = JsonSerializer.Serialize(logEntry, _jsonOptions);
        
        // è¼¸å‡ºåˆ° consoleï¼ˆæœ‰é¡è‰²ï¼‰å’Œæª”æ¡ˆï¼ˆç´”æ–‡å­—ï¼‰
        WriteToConsole(logLevel, json);
        WriteToFile(json);
    }
    
    private void WriteToConsole(LogLevel logLevel, string json)
    {
        var color = logLevel switch
        {
            LogLevel.Error => ConsoleColor.Red,
            LogLevel.Warning => ConsoleColor.Yellow,
            LogLevel.Information => ConsoleColor.White,
            LogLevel.Debug => ConsoleColor.Gray,
            _ => ConsoleColor.DarkGray
        };
        
        var originalColor = Console.ForegroundColor;
        Console.ForegroundColor = color;
        Console.WriteLine(json);
        Console.ForegroundColor = originalColor;
    }
    
    private void WriteToFile(string json)
    {
        var logFile = Path.Combine("logs", $"app-{DateTime.Now:yyyyMMdd}.log");
        Directory.CreateDirectory(Path.GetDirectoryName(logFile)!);
        
        // ä½¿ç”¨éé˜»å¡å¯«å…¥ï¼Œé¿å…å½±éŸ¿æ‡‰ç”¨æ•ˆèƒ½
        _ = Task.Run(async () =>
        {
            try
            {
                await File.AppendAllTextAsync(logFile, json + Environment.NewLine);
            }
            catch
            {
                // éœé»˜è™•ç†æª”æ¡ˆå¯«å…¥éŒ¯èª¤ï¼Œé¿å…å½±éŸ¿ä¸»è¦åŠŸèƒ½
            }
        });
    }
    
    private Dictionary<string, object> ExtractProperties<TState>(TState state)
    {
        var properties = new Dictionary<string, object>();
        
        if (state is IEnumerable<KeyValuePair<string, object>> enumerable)
        {
            foreach (var kvp in enumerable)
            {
                if (kvp.Key != "{OriginalFormat}")
                {
                    properties[kvp.Key] = kvp.Value;
                }
            }
        }
        
        return properties;
    }
    
    private object GetServiceContext()
    {
        return new
        {
            ServiceName = Environment.GetEnvironmentVariable("SERVICE_NAME") ?? "Coordinator",
            ShardId = Environment.GetEnvironmentVariable("SHARD_ID"),
            ProcessId = Environment.ProcessId,
            MachineName = Environment.MachineName,
            Version = Assembly.GetEntryAssembly()?.GetName().Version?.ToString()
        };
    }
}
```

**æ—¥èªŒæä¾›è€…æ•´åˆï¼š**
```csharp
public class StructuredLoggerProvider : ILoggerProvider
{
    private readonly ConcurrentDictionary<string, StructuredLogger> _loggers = new();
    
    public ILogger CreateLogger(string categoryName)
    {
        return _loggers.GetOrAdd(categoryName, name => new StructuredLogger(name));
    }
    
    public void Dispose()
    {
        _loggers.Clear();
    }
}

// Program.cs æ•´åˆ
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureLogging(logging =>
        {
            logging.ClearProviders();
            logging.AddProvider(new StructuredLoggerProvider());
        })
        .ConfigureServices((context, services) =>
        {
            services.AddHostedService<ConsoleMonitorService>();
        });
```

[Source: docs/brownfield-prd.md#NFR5 æ—¥èªŒå’Œç›£æ§]

### Discord Webhook é€šçŸ¥ç³»çµ±
**é€šçŸ¥æœå‹™å¯¦ä½œï¼š**
```csharp
public class DiscordNotificationService
{
    private readonly IHttpClientFactory _httpClientFactory;
    private readonly IConfiguration _configuration;
    private readonly ILogger<DiscordNotificationService> _logger;
    private readonly SemaphoreSlim _rateLimitSemaphore = new(1, 1);
    private DateTime _lastNotification = DateTime.MinValue;
    
    public DiscordNotificationService(
        IHttpClientFactory httpClientFactory,
        IConfiguration configuration,
        ILogger<DiscordNotificationService> logger)
    {
        _httpClientFactory = httpClientFactory;
        _configuration = configuration;
        _logger = logger;
    }
    
    public async Task SendServiceFailureNotificationAsync(string serviceName, string reason)
    {
        if (!ShouldSendNotification(NotificationSeverity.Error)) return;
        
        var embed = new
        {
            title = "ğŸš¨ æœå‹™æ•…éšœè­¦å ±",
            description = $"æœå‹™ **{serviceName}** ç™¼ç”Ÿæ•…éšœ",
            color = 15158332, // ç´…è‰²
            fields = new[]
            {
                new { name = "æœå‹™åç¨±", value = serviceName, inline = true },
                new { name = "æ•…éšœåŸå› ", value = reason, inline = true },
                new { name = "ç™¼ç”Ÿæ™‚é–“", value = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"), inline = true },
                new { name = "ä¸»æ©Ÿåç¨±", value = Environment.MachineName, inline = true }
            },
            timestamp = DateTime.UtcNow
        };
        
        await SendDiscordWebhookAsync(embed);
    }
    
    public async Task SendServiceRecoveryNotificationAsync(string serviceName, TimeSpan downtime)
    {
        if (!ShouldSendNotification(NotificationSeverity.Info)) return;
        
        var embed = new
        {
            title = "âœ… æœå‹™æ¢å¾©é€šçŸ¥",
            description = $"æœå‹™ **{serviceName}** å·²æ¢å¾©æ­£å¸¸",
            color = 5763719, // ç¶ è‰²
            fields = new[]
            {
                new { name = "æœå‹™åç¨±", value = serviceName, inline = true },
                new { name = "åœæ©Ÿæ™‚é–“", value = FormatDuration(downtime), inline = true },
                new { name = "æ¢å¾©æ™‚é–“", value = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"), inline = true }
            },
            timestamp = DateTime.UtcNow
        };
        
        await SendDiscordWebhookAsync(embed);
    }
    
    private async Task SendDiscordWebhookAsync(object embed)
    {
        var webhookUrl = _configuration["Discord:WebhookUrl"];
        if (string.IsNullOrEmpty(webhookUrl)) return;
        
        await _rateLimitSemaphore.WaitAsync();
        try
        {
            var payload = new
            {
                username = "Discord Stream Bot Monitor",
                avatar_url = "https://cdn.discordapp.com/embed/avatars/0.png",
                embeds = new[] { embed }
            };
            
            var client = _httpClientFactory.CreateClient();
            client.Timeout = TimeSpan.FromSeconds(10);
            
            var json = JsonSerializer.Serialize(payload);
            var content = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await client.PostAsync(webhookUrl, content);
            
            if (response.IsSuccessStatusCode)
            {
                _logger.LogInformation("Discord é€šçŸ¥ç™¼é€æˆåŠŸ");
            }
            else
            {
                _logger.LogWarning("Discord é€šçŸ¥ç™¼é€å¤±æ•—: {StatusCode}", response.StatusCode);
            }
            
            _lastNotification = DateTime.Now;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ç™¼é€ Discord é€šçŸ¥æ™‚ç™¼ç”Ÿä¾‹å¤–");
        }
        finally
        {
            _rateLimitSemaphore.Release();
        }
    }
    
    private bool ShouldSendNotification(NotificationSeverity severity)
    {
        // é˜²æ­¢é€šçŸ¥æ´ªæ°´ï¼šåŒä¸€åš´é‡ç¨‹åº¦é€šçŸ¥é–“éš”è‡³å°‘ 5 åˆ†é˜
        var minInterval = severity switch
        {
            NotificationSeverity.Error => TimeSpan.FromMinutes(5),
            NotificationSeverity.Warning => TimeSpan.FromMinutes(10),
            NotificationSeverity.Info => TimeSpan.FromMinutes(15),
            _ => TimeSpan.FromHours(1)
        };
        
        return DateTime.Now - _lastNotification >= minInterval;
    }
}

public enum NotificationSeverity
{
    Error,
    Warning,
    Info
}
```

[Source: docs/brownfield-prd.md#å¯¦ä½œç•°å¸¸é€šçŸ¥æ©Ÿåˆ¶ï¼ˆDiscord Webhookï¼‰]

### Project Structure
æœ¬ Story å°‡åœ¨ç¾æœ‰ Coordinator å°ˆæ¡ˆä¸­æ–°å¢éƒ¨ç½²å’Œç›£æ§åŠŸèƒ½ï¼š
```
StreamNotifyBot.Coordinator/
â”œâ”€â”€ Scripts/
â”‚   â”œâ”€â”€ start-services.sh           # æœ¬ Story æ–°å¢
â”‚   â”œâ”€â”€ stop-services.sh            # æœ¬ Story æ–°å¢
â”‚   â””â”€â”€ install-deps.sh             # æœ¬ Story æ–°å¢
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ ConsoleMonitorService.cs    # æœ¬ Story æ–°å¢
â”‚   â””â”€â”€ DiscordNotificationService.cs # æœ¬ Story æ–°å¢
â”œâ”€â”€ Logging/
â”‚   â”œâ”€â”€ StructuredLogger.cs         # æœ¬ Story æ–°å¢
â”‚   â”œâ”€â”€ StructuredLoggerProvider.cs # æœ¬ Story æ–°å¢
â”‚   â””â”€â”€ LogEntry.cs                 # æœ¬ Story æ–°å¢
â”œâ”€â”€ Models/
â”‚   â””â”€â”€ NotificationModels.cs       # æœ¬ Story æ–°å¢
â””â”€â”€ logs/                           # æœ¬ Story æ–°å¢ï¼ˆæ—¥èªŒç›®éŒ„ï¼‰
```

[Source: docs/brownfield-architecture.md#å¯¦éš›æŠ€è¡“å †ç–Š]

### è¨­å®šæª”æ•´åˆ
**æ“´å±• appsettings.jsonï¼š**
```json
{
  "MonitoringConsole": {
    "RefreshIntervalMs": 1000,
    "MaxLogLines": 100,
    "EnableInteractiveMode": true,
    "LogFile": "logs/app-{Date}.log"
  },
  "Discord": {
    "WebhookUrl": "{{DISCORD_WEBHOOK_URL}}",
    "NotificationSettings": {
      "EnableFailureAlerts": true,
      "EnableRecoveryAlerts": true,
      "RateLimitMinutes": 5,
      "MinSeverityLevel": "Warning"
    }
  },
  "Tmux": {
    "SessionName": "discord-stream-bot",
    "SessionTimeout": 300,
    "GracefulShutdownTimeout": 30
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "StreamNotifyBot.Coordinator.Logging": "Debug"
    },
    "StructuredLogging": {
      "EnableConsoleColors": true,
      "EnableFileLogging": true,
      "MaxLogFileSizeMB": 100,
      "RetainLogDays": 7
    }
  }
}
```

**coord.yml ç›£æ§è¨­å®šæ“´å±•ï¼š**
```yaml
monitoring:
  recheckIntervalMs: 2000
  unresponsiveSec: 30
  maxRestartAttempts: 3
  restartDelayMs: 5000
  autoRestart: true
  
  # æ–°å¢ç›£æ§è¨­å®š
  console:
    refreshIntervalMs: 1000
    maxDisplayLogs: 50
    enableColors: true
    interactiveMode: true
    
  notifications:
    discord:
      webhookUrl: "{{DISCORD_WEBHOOK_URL}}"
      enableFailureAlerts: true
      enableRecoveryAlerts: true
      rateLimitMinutes: 5
      
  logging:
    structured: true
    outputFormat: "json"
    logLevel: "Information"
    fileRotation:
      maxSizeMB: 100
      retainDays: 7
```

[Source: docs/brownfield-architecture.md#çµ±ä¸€é…ç½®ç®¡ç†]

### éƒ¨ç½²æµç¨‹æ•´åˆ
**å®Œæ•´éƒ¨ç½²æµç¨‹ï¼š**
```bash
# 1. ç’°å¢ƒæº–å‚™
./Scripts/install-deps.sh

# 2. è¨­å®šé…ç½®
cp coord.example.yml coord.yml
# ç·¨è¼¯ coord.yml è¨­å®šç’°å¢ƒè®Šæ•¸

# 3. å•Ÿå‹•æœå‹™
./Scripts/start-services.sh

# 4. æª¢è¦–ç›£æ§
tmux attach-session -t discord-stream-bot
tmux select-window -t discord-stream-bot:monitor

# 5. åœæ­¢æœå‹™ï¼ˆéœ€è¦æ™‚ï¼‰
./Scripts/stop-services.sh
```

**å¥åº·æª¢æŸ¥æ•´åˆï¼š**
```csharp
public class SystemHealthService
{
    public async Task<HealthCheckResult> CheckSystemHealthAsync()
    {
        var results = new List<HealthCheckItem>();
        
        // æª¢æŸ¥å„æœå‹™ç‹€æ…‹
        var services = await _processManager.GetAllServicesAsync();
        foreach (var service in services)
        {
            results.Add(new HealthCheckItem
            {
                Name = service.Name,
                Status = service.Status == ServiceStatus.Running ? "Healthy" : "Unhealthy",
                LastCheck = DateTime.UtcNow,
                Details = new { service.Uptime, service.MemoryUsageMB }
            });
        }
        
        // æª¢æŸ¥ tmux session
        var sessionExists = await CheckTmuxSessionAsync();
        results.Add(new HealthCheckItem
        {
            Name = "Tmux Session",
            Status = sessionExists ? "Healthy" : "Unhealthy",
            LastCheck = DateTime.UtcNow
        });
        
        // æª¢æŸ¥ç£ç¢Ÿç©ºé–“
        var diskSpace = await CheckDiskSpaceAsync();
        results.Add(new HealthCheckItem
        {
            Name = "Disk Space",
            Status = diskSpace > 1024 ? "Healthy" : "Warning", // 1GB æœ€å°ç©ºé–“
            LastCheck = DateTime.UtcNow,
            Details = new { AvailableSpaceMB = diskSpace }
        });
        
        return new HealthCheckResult
        {
            OverallStatus = results.All(r => r.Status == "Healthy") ? "Healthy" : "Degraded",
            Checks = results,
            Timestamp = DateTime.UtcNow
        };
    }
}
```

[Source: docs/brownfield-prd.md#éƒ¨ç½²é †åº]

### Testing

**å–®å…ƒæ¸¬è©¦éœ€æ±‚ï¼š**
- tmux è…³æœ¬åŠŸèƒ½æ¸¬è©¦ï¼ˆæ¨¡æ“¬ç’°å¢ƒï¼‰
- Console ç›£æ§ä»‹é¢é‚è¼¯æ¸¬è©¦
- çµæ§‹åŒ–æ—¥èªŒæ ¼å¼å’Œè¼¸å‡ºæ¸¬è©¦
- Discord Webhook é€šçŸ¥æ©Ÿåˆ¶æ¸¬è©¦

**æ•´åˆæ¸¬è©¦éœ€æ±‚ï¼š**
- å®Œæ•´éƒ¨ç½²æµç¨‹æ¸¬è©¦
- æœå‹™æ•…éšœå ´æ™¯ä¸‹çš„é€šçŸ¥æ©Ÿåˆ¶æ¸¬è©¦
- é•·æ™‚é–“é‹è¡Œçš„ç›£æ§ç©©å®šæ€§æ¸¬è©¦

**æ¸¬è©¦å·¥å…·å’Œæ¡†æ¶ï¼š**
- xUnit ä½œç‚ºæ¸¬è©¦æ¡†æ¶
- Moq ç”¨æ–¼æ¨¡æ“¬ HTTP å’Œæª”æ¡ˆç³»çµ±æ“ä½œ
- Microsoft.AspNetCore.TestHost ç”¨æ–¼ Web API æ¸¬è©¦
- è‡ªè¨‚ TmuxTestHelper é¡åˆ¥æ¨¡æ“¬ tmux æ“ä½œ

**æ¸¬è©¦è…³æœ¬ç¯„ä¾‹ï¼š**
```bash
#!/bin/bash
# test-deployment.sh

# æ¨¡æ“¬éƒ¨ç½²æ¸¬è©¦
TEST_SESSION="test-discord-bot"

cleanup() {
    tmux kill-session -t "$TEST_SESSION" 2>/dev/null || true
}

trap cleanup EXIT

# æ¸¬è©¦å•Ÿå‹•è…³æœ¬
echo "æ¸¬è©¦æœå‹™å•Ÿå‹•..."
SESSION_NAME="$TEST_SESSION" ./Scripts/start-services.sh

# ç­‰å¾…æœå‹™å•Ÿå‹•
sleep 30

# æª¢æŸ¥æœå‹™ç‹€æ…‹
if curl -sf http://localhost:6110/health; then
    echo "âœ… å¥åº·æª¢æŸ¥é€šé"
else
    echo "âŒ å¥åº·æª¢æŸ¥å¤±æ•—"
    exit 1
fi

# æ¸¬è©¦åœæ­¢è…³æœ¬
echo "æ¸¬è©¦æœå‹™åœæ­¢..."
SESSION_NAME="$TEST_SESSION" ./Scripts/stop-services.sh

echo "âœ… éƒ¨ç½²æ¸¬è©¦å®Œæˆ"
```

[Source: docs/brownfield-architecture.md#æ¸¬è©¦ç­–ç•¥]

### æ•ˆèƒ½å’Œè³‡æºè€ƒé‡
- **ç›£æ§é »ç‡**: 1 ç§’æ›´æ–°é–“éš”ï¼Œå¹³è¡¡å³æ™‚æ€§å’Œ CPU ä½¿ç”¨
- **æ—¥èªŒæª”æ¡ˆç®¡ç†**: è‡ªå‹•è¼ªè½‰ï¼Œé è¨­ä¿ç•™ 7 å¤©ï¼Œå–®æª”æœ€å¤§ 100MB
- **è¨˜æ†¶é«”ä½¿ç”¨**: ç›£æ§ä»‹é¢é™åˆ¶æœ€å¤šé¡¯ç¤º 100 è¡Œæ—¥èªŒï¼Œé¿å…è¨˜æ†¶é«”æ´©æ¼
- **é€šçŸ¥é »ç‡é™åˆ¶**: åŒç­‰ç´šé€šçŸ¥é–“éš”è‡³å°‘ 5 åˆ†é˜ï¼Œé˜²æ­¢é€šçŸ¥æ´ªæ°´
- **tmux æœƒè©±ç®¡ç†**: è‡ªå‹•æª¢æŸ¥é‡è¤‡æœƒè©±ï¼Œé¿å…è³‡æºæµªè²»

[Source: docs/brownfield-prd.md#NFR4 è³‡æºä½¿ç”¨æ•ˆç‡]

### å®‰å…¨å’Œç©©å®šæ€§è€ƒé‡
- **è…³æœ¬æ¬Šé™æ§åˆ¶**: åŸ·è¡Œè…³æœ¬éœ€è¦é©ç•¶çš„æª”æ¡ˆæ¬Šé™
- **Discord Webhook ä¿è­·**: Webhook URL é€éç’°å¢ƒè®Šæ•¸é…ç½®ï¼Œä¸å¯«å…¥æ—¥èªŒ
- **å„ªé›…é—œé–‰**: ç¢ºä¿æœå‹™åœæ­¢æ™‚æ­£ç¢ºæ¸…ç†è³‡æºå’Œä¿å­˜ç‹€æ…‹
- **éŒ¯èª¤æ¢å¾©**: ç›£æ§ä»‹é¢å´©æ½°æ™‚ä¸å½±éŸ¿ä¸»è¦æœå‹™é‹è¡Œ
- **æ—¥èªŒå®‰å…¨**: æ•æ„Ÿè³‡è¨Šï¼ˆTokenã€å¯†ç¢¼ï¼‰è‡ªå‹•é®ç½©è™•ç†

[Source: docs/brownfield-prd.md#æŠ€è¡“ç´„æŸå’Œé™åˆ¶]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | å»ºç«‹ tmux éƒ¨ç½²è…³æœ¬å’Œç›£æ§ä»‹é¢æ•…äº‹ | Scrum Master |
