# Story 3.2: 進程生命週期管理系統

## Status
Draft

## Story
**As a** 系統管理員,
**I want** Coordinator 服務能自動管理 Crawler 和多個 Discord Shard 進程的完整生命週期,
**so that** 系統能自動處理服務啟動順序、故障檢測和重啟，確保整個架構穩定運行且無需手動干預

## Acceptance Criteria

1. 建立 `ProcessManager.cs` 管理服務進程，支援同時管理 Crawler 服務和多個 Discord Shard 進程
2. 實作服務啟動順序控制，確保 Crawler 服務先啟動並穩定後再啟動 Discord Shard
3. 建立進程健康檢查和故障檢測機制，能自動檢測服務失效並觸發重啟
4. 支援動態 Discord Shard 數量管理，使用 `BaseDiscordClient.GetRecommendedShardCountAsync()` 決定 Shard 數量

## Tasks / Subtasks

- [ ] 建立 ProcessManager 核心類別 (AC: 1)
  - [ ] 建立 `Services/ProcessManager.cs` 類別
  - [ ] 定義 `ServiceDefinition` 模型包含服務類型、啟動指令、依賴關係
  - [ ] 實作併發安全的服務實例字典管理
  - [ ] 建立服務狀態枚舉（Starting, Running, Stopping, Failed）

- [ ] 實作服務啟動順序控制邏輯 (AC: 2)
  - [ ] 建立 `StartServicesAsync()` 方法實作依賴順序啟動
  - [ ] 實作 Crawler 服務優先啟動和健康等待機制
  - [ ] 實作 Discord Shard 並行啟動（Crawler 穩定後）
  - [ ] 建立服務依賴圖解析和循環依賴檢測

- [ ] 建立進程健康檢查系統 (AC: 3)
  - [ ] 實作 `HealthCheckService` 背景服務定期檢查進程狀態
  - [ ] 建立 HTTP 健康檢查機制（針對 Crawler 服務）
  - [ ] 建立 gRPC 心跳檢查機制（針對 Discord Shard）
  - [ ] 實作進程故障自動檢測和重啟邏輯

- [ ] 實作動態 Shard 數量管理 (AC: 4)
  - [ ] 整合 `BaseDiscordClient.GetRecommendedShardCountAsync()` 動態決定 Shard 數量
  - [ ] 建立 Shard 配置生成器，根據建議數量產生啟動參數
  - [ ] 實作 Shard 數量變更時的優雅重啟機制
  - [ ] 支援手動覆蓋 Shard 數量的配置選項

## Dev Notes

### Previous Story Insights
基於 Story 3.1 已建立的 gRPC 服務和服務狀態管理，本 Story 將建立完整的進程管理能力。

### 服務管理架構設計
基於 Coordinator 模式和 NadekoBot 的進程管理機制設計：

**核心服務定義模型：**
```csharp
public enum ServiceType
{
    Crawler,
    DiscordShard
}

public enum ServiceStatus
{
    Starting,    // 進程啟動中
    Running,     // 正常運行
    Stopping,    // 關閉中
    Failed,      // 故障狀態
    Restarting   // 重啟中
}

public class ServiceDefinition
{
    public string Id { get; set; }                    // 服務唯一識別符
    public ServiceType Type { get; set; }             // 服務類型
    public string Command { get; set; }               // 啟動指令
    public string[] Args { get; set; }                // 啟動參數
    public string WorkingDirectory { get; set; }      // 工作目錄
    public Dictionary<string, string> Environment { get; set; }  // 環境變數
    public HealthCheckConfig HealthCheck { get; set; } // 健康檢查配置
    public string[] Dependencies { get; set; }        // 依賴服務
    public int ShardId { get; set; } = -1;           // Discord Shard 編號
}
```

[Source: docs/brownfield-architecture.md#Coordinator 架構設計]

**服務啟動順序控制：**
```csharp
public class ProcessManager
{
    private readonly ConcurrentDictionary<string, ManagedProcess> _processes = new();
    private readonly ServiceStateManager _stateManager;
    
    public async Task StartServicesAsync()
    {
        // 1. 先啟動 Crawler 服務
        var crawlerService = _services.First(s => s.Type == ServiceType.Crawler);
        await StartServiceAsync(crawlerService);
        await WaitForHealthyAsync(crawlerService, TimeSpan.FromMinutes(2));
        
        // 2. Crawler 健康後計算 Discord Shard 數量
        var recommendedShards = await GetRecommendedShardCountAsync();
        var discordShards = GenerateDiscordShardDefinitions(recommendedShards);
        
        // 3. 並行啟動所有 Discord Shard
        var shardTasks = discordShards.Select(StartServiceAsync);
        await Task.WhenAll(shardTasks);
        
        // 4. 等待所有 Shard 連接成功
        await WaitForAllShardsReadyAsync(TimeSpan.FromMinutes(5));
    }
}
```

[Source: docs/brownfield-architecture.md#服務啟動順序管理]

### 進程管理實作詳細
**進程包裝器設計：**
```csharp
public class ManagedProcess : IDisposable
{
    private readonly ServiceDefinition _definition;
    private Process _process;
    private readonly CancellationTokenSource _cancellation = new();
    
    public string ServiceId => _definition.Id;
    public ServiceStatus Status { get; private set; }
    public DateTime LastStartTime { get; private set; }
    public TimeSpan Uptime => DateTime.UtcNow - LastStartTime;
    
    public async Task<bool> StartAsync()
    {
        var processInfo = new ProcessStartInfo
        {
            FileName = _definition.Command,
            Arguments = string.Join(" ", _definition.Args),
            WorkingDirectory = _definition.WorkingDirectory,
            UseShellExecute = false,
            RedirectStandardOutput = true,
            RedirectStandardError = true
        };
        
        // 設定環境變數
        foreach (var env in _definition.Environment)
        {
            processInfo.Environment[env.Key] = env.Value;
        }
        
        _process = Process.Start(processInfo);
        Status = ServiceStatus.Starting;
        LastStartTime = DateTime.UtcNow;
        
        // 監控進程狀態
        _ = Task.Run(MonitorProcessAsync);
        
        return _process != null && !_process.HasExited;
    }
}
```

**健康檢查機制：**
```csharp
public class HealthCheckService : BackgroundService
{
    private readonly ProcessManager _processManager;
    private readonly IHttpClientFactory _httpClientFactory;
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            await CheckAllServicesHealthAsync();
            await Task.Delay(TimeSpan.FromSeconds(10), stoppingToken);
        }
    }
    
    private async Task CheckAllServicesHealthAsync()
    {
        var services = _processManager.GetAllServices();
        
        foreach (var service in services)
        {
            try
            {
                bool isHealthy = service.Type switch
                {
                    ServiceType.Crawler => await CheckHttpHealthAsync(service),
                    ServiceType.DiscordShard => await CheckGrpcHeartbeatAsync(service),
                    _ => false
                };
                
                if (!isHealthy && service.Status == ServiceStatus.Running)
                {
                    await _processManager.HandleServiceFailureAsync(service);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "健康檢查失敗: {ServiceId}", service.Id);
            }
        }
    }
}
```

[Source: docs/brownfield-prd.md#NFR2 系統可用性]

### Discord Shard 動態數量管理
**Shard 數量決定邏輯：**
```csharp
public class ShardConfigurationService
{
    private readonly IConfiguration _configuration;
    
    public async Task<int> GetRecommendedShardCountAsync()
    {
        // 1. 檢查是否有手動覆蓋設定
        var manualOverride = _configuration.GetValue<int?>("Discord:ManualShardCount");
        if (manualOverride.HasValue && manualOverride.Value > 0)
        {
            return manualOverride.Value;
        }
        
        // 2. 使用 Discord.Net 建議的 Shard 數量
        var config = new DiscordSocketConfig();
        var client = new DiscordSocketClient(config);
        
        try
        {
            var recommended = await BaseDiscordClient.GetRecommendedShardCountAsync(_botToken);
            return Math.Max(1, recommended);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "無法取得建議 Shard 數量，使用預設值 1");
            return 1;
        }
        finally
        {
            client?.Dispose();
        }
    }
    
    public ServiceDefinition[] GenerateDiscordShardDefinitions(int totalShards)
    {
        var shards = new ServiceDefinition[totalShards];
        
        for (int i = 0; i < totalShards; i++)
        {
            shards[i] = new ServiceDefinition
            {
                Id = $"discord-shard-{i}",
                Type = ServiceType.DiscordShard,
                Command = "dotnet",
                Args = new[] { "run", "--project", "DiscordStreamNotifyBot", i.ToString(), totalShards.ToString() },
                WorkingDirectory = _configuration["Paths:DiscordBotProject"],
                Environment = new Dictionary<string, string>
                {
                    ["REDIS_CONNECTION"] = _configuration["Redis:ConnectionString"],
                    ["DATABASE_CONNECTION"] = _configuration["Database:ConnectionString"],
                    ["COORDINATOR_ENDPOINT"] = _configuration["Coordinator:GrpcEndpoint"]
                },
                Dependencies = new[] { "crawler" },
                ShardId = i
            };
        }
        
        return shards;
    }
}
```

[Source: docs/brownfield-prd.md#NFR3 可擴展性]

### 故障處理和重啟策略
**分類故障處理：**
```csharp
public async Task HandleServiceFailureAsync(ServiceDefinition service)
{
    _logger.LogWarning("服務故障檢測: {ServiceId} (Type: {Type})", service.Id, service.Type);
    
    if (service.Type == ServiceType.Crawler)
    {
        // Crawler 故障影響整個系統，需要重啟所有服務
        _logger.LogCritical("Crawler 服務故障，重啟整個系統");
        await RestartAllServicesAsync();
    }
    else if (service.Type == ServiceType.DiscordShard)
    {
        // Discord Shard 故障只重啟該 Shard
        _logger.LogWarning("Discord Shard 故障，僅重啟該 Shard: {ShardId}", service.ShardId);
        await RestartServiceAsync(service);
    }
}

private async Task RestartServiceAsync(ServiceDefinition service)
{
    var managedProcess = _processes[service.Id];
    
    // 1. 優雅關閉
    await managedProcess.StopAsync(TimeSpan.FromSeconds(30));
    
    // 2. 等待一小段時間
    await Task.Delay(TimeSpan.FromSeconds(5));
    
    // 3. 重新啟動
    var success = await managedProcess.StartAsync();
    
    if (success)
    {
        _logger.LogInformation("服務重啟成功: {ServiceId}", service.Id);
    }
    else
    {
        _logger.LogError("服務重啟失敗: {ServiceId}", service.Id);
        // 可以考慮通知機制或進一步的故障處理
    }
}
```

[Source: docs/brownfield-architecture.md#服務啟動順序管理]

### Project Structure
本 Story 將在現有 Coordinator 專案中新增進程管理功能：
```
StreamNotifyBot.Coordinator/
├── Services/
│   ├── CoordinatorService.cs        # Story 3.1 已建立
│   ├── ServiceStateManager.cs      # Story 3.1 已建立
│   ├── ProcessManager.cs           # 本 Story 新增
│   ├── HealthCheckService.cs       # 本 Story 新增
│   └── ShardConfigurationService.cs # 本 Story 新增
├── Models/
│   ├── ServiceInfo.cs              # Story 3.1 已建立
│   ├── ServiceDefinition.cs        # 本 Story 新增
│   └── ManagedProcess.cs           # 本 Story 新增
└── Configuration/
    └── ProcessManagerOptions.cs     # 本 Story 新增
```

[Source: docs/brownfield-architecture.md#實際技術堆疊]

### 設定檔整合
**擴展現有 appsettings.json：**
```json
{
  "ProcessManager": {
    "HealthCheckIntervalSeconds": 10,
    "ServiceStartTimeoutMinutes": 2,
    "ShardStartupTimeoutMinutes": 5,
    "MaxRestartAttempts": 3,
    "RestartDelaySeconds": 5
  },
  "ServiceDefinitions": {
    "Crawler": {
      "Command": "dotnet",
      "Args": ["run", "--project", "StreamNotifyBot.Crawler"],
      "WorkingDirectory": "{{WorkspacePath}}/StreamNotifyBot.Crawler",
      "HealthCheck": {
        "Type": "Http",
        "Endpoint": "http://localhost:6111/health",
        "TimeoutSeconds": 5
      }
    },
    "DiscordShard": {
      "Command": "dotnet", 
      "Args": ["run", "--project", "DiscordStreamNotifyBot", "{shardId}", "{totalShards}"],
      "WorkingDirectory": "{{WorkspacePath}}/DiscordStreamNotifyBot",
      "HealthCheck": {
        "Type": "Grpc",
        "TimeoutSeconds": 3
      }
    }
  },
  "Discord": {
    "BotToken": "{{DISCORD_BOT_TOKEN}}",
    "ManualShardCount": null
  }
}
```

[Source: docs/brownfield-architecture.md#統一配置管理]

### 日誌和監控整合
**結構化日誌輸出：**
```csharp
public class ProcessManager
{
    private readonly ILogger<ProcessManager> _logger;
    
    private void LogServiceEvent(string serviceId, string eventType, object additionalData = null)
    {
        _logger.LogInformation(
            "服務事件: {EventType} | 服務: {ServiceId} | 資料: {@Data}", 
            eventType, serviceId, additionalData);
    }
    
    // 使用範例
    LogServiceEvent(service.Id, "ServiceStarted", new { Uptime = service.Uptime });
    LogServiceEvent(service.Id, "HealthCheckFailed", new { Reason = ex.Message });
}
```

監控指標（為 Story 3.5 Prometheus 整合做準備）：
- 服務狀態統計
- 重啟次數計數器
- 服務運行時間
- 健康檢查成功率

[Source: docs/brownfield-prd.md#NFR5 日誌和監控]

### Testing

**單元測試需求：**
- ProcessManager 服務啟動順序邏輯測試
- ManagedProcess 生命週期管理測試
- HealthCheckService 故障檢測測試
- ShardConfigurationService Shard 數量計算測試

**整合測試需求：**
- 完整服務啟動流程測試
- 服務故障和自動重啟測試
- 動態 Shard 數量調整測試

**測試工具和框架：**
- xUnit 作為測試框架
- Moq 用於模擬 Process 和 HTTP 呼叫
- TestContainers 用於整合測試環境設定
- 自訂 MockProcess 類別模擬進程行為

[Source: docs/brownfield-architecture.md#測試策略]

### 技術約束和限制
- 使用 .NET Process 類別管理子進程，支援跨平台
- 健康檢查超時設定需要平衡回應速度和系統負載
- 進程重啟策略需要考慮資料庫連接池和 Redis 連接的清理
- Shard 數量變更需要考慮 Discord API Rate Limit 影響

[Source: docs/brownfield-prd.md#技術約束和限制]

### 安全和穩定性考量
- 進程管理需要適當的權限控制
- 環境變數包含敏感資訊，需要安全處理
- 服務重啟時需要優雅關閉避免資料遺失
- 死鎖預防：避免服務間等待造成的循環依賴

[Source: docs/brownfield-prd.md#技術約束和限制]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | 建立進程生命週期管理系統故事 | Scrum Master |
