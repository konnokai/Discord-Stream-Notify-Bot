# Story 2.5: 事件廣播和追蹤管理系統

## Status
Draft

## Story
**As a** 系統架構師,
**I want** 實作直播狀態廣播和動態追蹤管理機制，完善服務間通訊,
**so that** 直播狀態事件能被正確廣播到所有 Discord Shard，並且能動態調整爬蟲目標以優化資源使用

## Acceptance Criteria

1. [ ] 建立 `TrackingManager.cs` 管理全域追蹤計數器
   - 維護 `Dictionary<StreamKey, HashSet<GuildId>>` 追蹤映射
   - 支援追蹤目標新增和移除
   - 計數器歸零時停止對應爬蟲
2. [ ] 實作 `stream.follow`/`stream.unfollow` 事件處理
   - 監聽 Discord Bot 發送的追蹤事件
   - 更新全域追蹤計數器
   - 動態啟動/停止平台監控
3. [ ] 建立批量事件廣播機制（`streams.online`/`streams.offline`）
   - 收集同時段的狀態變化
   - 批量發送減少 PubSub 負載
   - 支援單一和批量事件格式
4. [ ] 實作動態追蹤目標調整（無 Guild 追蹤時停止爬蟲）
   - 即時調整監控目標清單
   - 避免不必要的 API 調用
   - 支援追蹤目標重新啟動
5. [ ] 維持外部錄影工具事件格式相容性
   - 保持現有事件名稱和格式
   - 向後相容性確保
   - 新舊事件格式並存支援
6. [ ] 實作追蹤狀態持久化和恢復
   - 啟動時從資料庫載入追蹤目標
   - 定期同步記憶體狀態到資料庫
   - 服務重啟後狀態恢復

## Tasks / Subtasks

- [ ] Task 1: 建立追蹤管理核心架構 (AC: 1, 4)
  - [ ] 建立 `Services/TrackingManager.cs` 主要追蹤管理器
  - [ ] 定義 `StreamKey` 資料模型（平台 + 識別符組合）
  - [ ] 實作全域追蹤計數器：`ConcurrentDictionary<StreamKey, HashSet<ulong>>`
  - [ ] 建立執行緒安全的追蹤操作方法
  - [ ] 實作追蹤計數器監控和日誌記錄

- [ ] Task 2: 實作 Redis PubSub 事件監聽 (AC: 2)
  - [ ] 建立 `EventHandlers/TrackingEventListener.cs` 監聽追蹤事件
  - [ ] 實作 `stream.follow` 事件處理：
    - 反序列化 `StreamFollowEvent` 事件資料
    - 更新全域追蹤計數器（新增 Guild）
    - 第一次追蹤時觸發平台監控器啟動
  - [ ] 實作 `stream.unfollow` 事件處理：
    - 反序列化 `StreamUnfollowEvent` 事件資料  
    - 更新全域追蹤計數器（移除 Guild）
    - 計數器歸零時觸發平台監控器停止
  - [ ] 建立事件處理錯誤恢復機制
  - [ ] 實作併發事件處理和去重機制

- [ ] Task 3: 實作動態平台監控管理 (AC: 2, 4)
  - [ ] 建立 `IPlatformManager` 介面定義監控器協調方法
  - [ ] 實作 `PlatformManager.cs` 統一管理各平台監控器
  - [ ] 建立動態監控目標調整機制：
    - `StartTrackingAsync(StreamKey key)` - 開始追蹤特定目標
    - `StopTrackingAsync(StreamKey key)` - 停止追蹤特定目標
    - `UpdateTrackingTargetsAsync()` - 批量更新監控目標清單
  - [ ] 整合各平台監控器（YouTube、Twitch、Twitter、TwitCasting）
  - [ ] 實作監控器狀態管理和故障恢復

- [ ] Task 4: 建立批量事件廣播機制 (AC: 3, 5)
  - [ ] 建立 `Services/EventBroadcastService.cs` 統一事件廣播
  - [ ] 實作事件收集和批量處理：
    - 定時收集狀態變化事件（例如每 30 秒一次）
    - 批量合併相同平台的多個事件
    - 避免同一直播短時間內重複通知
  - [ ] 實作 `streams.online` 批量廣播：
    - 收集所有開台事件組成批量事件
    - 包含多個 `StreamData` 的陣列格式
    - 保持與現有格式相容性
  - [ ] 實作 `streams.offline` 批量廣播：
    - 收集所有關台事件組成批量事件
    - 支援批量和單一事件格式
  - [ ] 建立事件廣播失敗重試機制
  - [ ] 實作外部錄影工具事件格式相容性檢查

- [ ] Task 5: 實作追蹤狀態持久化 (AC: 6)
  - [ ] 建立 `Services/TrackingPersistenceService.cs` 狀態持久化
  - [ ] 實作資料庫狀態載入機制：
    - 啟動時從各平台通知設定表載入追蹤目標
    - 重建全域追蹤計數器
    - 驗證資料庫和記憶體狀態一致性
  - [ ] 實作定期狀態同步機制：
    - 每 10 分鐘同步記憶體狀態到資料庫
    - 處理資料庫操作失敗的重試
    - 記錄狀態同步的詳細日誌
  - [ ] 建立服務重啟恢復流程：
    - 載入上次的追蹤狀態
    - 重新啟動必要的平台監控器
    - 驗證恢復狀態的正確性
  - [ ] 實作狀態一致性檢查和自我修復

- [ ] Task 6: 整合平台監控器動態控制 (AC: 1, 2, 4)
  - [ ] 修改現有平台監控器支援動態目標調整
  - [ ] 建立監控器與追蹤管理器的介面：
    - 監控器註冊到追蹤管理器
    - 接收動態追蹤目標更新
    - 回報監控狀態和異常
  - [ ] 實作各平台監控器的啟動/停止邏輯：
    - YouTube 監控器動態調整頻道清單
    - Twitch 監控器管理 EventSub 訂閱
    - Twitter 監控器調整 Spaces 監控目標
    - TwitCasting 監控器調整使用者清單
  - [ ] 建立監控器效能監控和優化
  - [ ] 實作監控器故障處理和自動恢復

- [ ] Task 7: 建立事件廣播效能優化 (AC: 3)
  - [ ] 實作事件去重機制防止重複廣播
  - [ ] 建立事件優先級管理：
    - 高優先級事件立即廣播
    - 低優先級事件批量處理
    - 支援緊急事件插隊機制
  - [ ] 實作廣播頻率控制和流量整形：
    - 限制每秒廣播事件數量
    - 避免 PubSub 頻道壅塞
    - 實作背壓處理機制
  - [ ] 建立事件統計和監控指標：
    - 廣播事件數量統計
    - 廣播延遲監控
    - 失敗重試統計
  - [ ] 實作記憶體使用優化和垃圾回收

- [ ] Task 8: 建立服務協調和配置管理 (AC: 1-6)
  - [ ] 擴展 Crawler 配置支援追蹤管理設定
  - [ ] 建立追蹤管理相關服務依賴注入配置：
    - 註冊 `TrackingManager` 為單例服務
    - 註冊 `TrackingEventListener` 為背景服務
    - 註冊 `EventBroadcastService` 和 `PlatformManager`
  - [ ] 實作健康檢查端點檢查追蹤管理狀態
  - [ ] 建立追蹤管理系統初始化和清理邏輯
  - [ ] 實作配置熱重載支援

- [ ] Task 9: 建立測試和驗證 (AC: 1-6)
  - [ ] 建立追蹤管理邏輯單元測試
  - [ ] 建立事件處理機制整合測試
  - [ ] 建立動態監控器控制測試
  - [ ] 建立批量事件廣播測試
  - [ ] 建立狀態持久化和恢復測試
  - [ ] 建立效能和負載測試

## Dev Notes

### 前一個故事的關鍵洞察
**[Source: Story 2.4 會員驗證跨服務協調系統]**

前一個故事建立了跨服務協調的基礎架構，包括：
- `ShardRoutingService.cs` - 實作 Guild ID 到 Shard ID 的路由計算
- `ShardRequestService.cs` - Redis PubSub 請求/回應模式
- `MemberVerificationService.cs` - 會員驗證邏輯遷移

這些為事件廣播和追蹤管理提供了重要的基礎設施。

### 系統架構上下文
**[Source: docs/brownfield-architecture.md#Shard 協調影響區域]**

**Crawler 服務（獨立專案）**：
- **專責爬蟲邏輯**：執行所有平台的直播狀態檢測
- **狀態變化廣播**：透過 Redis PubSub 通知所有 Discord Shard
- **追蹤管理**：監聽 follow/unfollow 事件，動態調整爬蟲目標
- **定期維護**：清理失效追蹤、API 配額管理、錯誤恢復

**Discord Shard 實例（純 Bot 功能）**：
- **通知處理**：監聽 Redis PubSub 事件發送 Discord 通知
- **指令處理**：處理 Discord 使用者互動和管理指令
- **Guild 管理**：根據本 Shard 分片處理對應 Guild

### Redis PubSub 頻道規範
**[Source: docs/brownfield-architecture.md#Redis-PubSub-頻道]**

**現有事件頻道**：
- `streams.online`: 直播開台事件，包含批量直播資料
- `streams.offline`: 直播關台事件，包含批量直播資料
- 保持與外部錄影工具的相容性，維持現有事件格式

**追蹤管理頻道**：
- `stream.follow`: Discord Shard → Crawler 新增追蹤請求
- `stream.unfollow`: Discord Shard → Crawler 移除追蹤請求

### 追蹤管理核心設計
**[Source: docs/epic-stories.md#Story 2.5 驗收標準]**

**全域追蹤計數器架構**：
```csharp
public class TrackingManager
{
    private readonly ConcurrentDictionary<StreamKey, HashSet<ulong>> _globalTrackCounter = new();
    private readonly object _trackLock = new object();
    
    public async Task HandleFollowRequest(StreamFollowEvent followEvent)
    {
        var key = new StreamKey(followEvent.Platform, followEvent.StreamKey);
        
        lock (_trackLock)
        {
            if (_globalTrackCounter.ContainsKey(key))
            {
                _globalTrackCounter[key].Add(followEvent.GuildId);
            }
            else
            {
                _globalTrackCounter[key] = new HashSet<ulong> { followEvent.GuildId };
                // 第一次追蹤，通知平台監控器開始追蹤
                await _platformManager.StartTrackingAsync(key);
            }
        }
    }
    
    public async Task HandleUnfollowRequest(StreamUnfollowEvent unfollowEvent)
    {
        var key = new StreamKey(unfollowEvent.Platform, unfollowEvent.StreamKey);
        
        lock (_trackLock)
        {
            if (_globalTrackCounter.TryGetValue(key, out var guilds))
            {
                guilds.Remove(unfollowEvent.GuildId);
                if (guilds.Count == 0)
                {
                    _globalTrackCounter.TryRemove(key, out _);
                    // 沒有 Guild 追蹤了，通知停止追蹤
                    await _platformManager.StopTrackingAsync(key);
                }
            }
        }
    }
}
```

**StreamKey 資料模型**：
```csharp
public class StreamKey
{
    public string Platform { get; set; } // youtube, twitch, twitter, twitcasting
    public string StreamIdentifier { get; set; } // 平台特定的識別符
    
    public StreamKey(string platform, string identifier)
    {
        Platform = platform;
        StreamIdentifier = identifier;
    }
    
    public override bool Equals(object obj) => 
        obj is StreamKey other && Platform == other.Platform && StreamIdentifier == other.StreamIdentifier;
    
    public override int GetHashCode() => 
        HashCode.Combine(Platform, StreamIdentifier);
}
```

### 事件資料模型
**[Source: Story 1.4 追蹤管理指令 PubSub 整合]**

**StreamFollowEvent 結構**：
```csharp
public class StreamFollowEvent
{
    [JsonProperty("platform")]
    public string Platform { get; set; } // youtube, twitch, twitter, twitcasting
    
    [JsonProperty("stream_key")]
    public string StreamKey { get; set; } // 平台特定的識別符
    
    [JsonProperty("guild_id")]
    public ulong GuildId { get; set; }
    
    [JsonProperty("channel_id")]
    public ulong ChannelId { get; set; } // Discord 通知頻道
    
    [JsonProperty("user_id")]
    public ulong UserId { get; set; } // 操作者
    
    [JsonProperty("timestamp")]
    public DateTime Timestamp { get; set; }
    
    [JsonProperty("metadata")]
    public Dictionary<string, object> Metadata { get; set; }
}

public class StreamUnfollowEvent
{
    [JsonProperty("platform")]
    public string Platform { get; set; }
    
    [JsonProperty("stream_key")]
    public string StreamKey { get; set; }
    
    [JsonProperty("guild_id")]
    public ulong GuildId { get; set; }
    
    [JsonProperty("user_id")]
    public ulong UserId { get; set; }
    
    [JsonProperty("timestamp")]
    public DateTime Timestamp { get; set; }
}
```

### 批量事件廣播設計
**[Source: Story 1.2 Redis PubSub 事件監聽器建立]**

**StreamStatusEvent 結構**：
```csharp
public class StreamStatusEvent
{
    public List<StreamData> Streams { get; set; }
    public bool IsOnline { get; set; }
    public string Platform { get; set; }
    public DateTime Timestamp { get; set; }
    public Dictionary<string, object> Metadata { get; set; }
}

public class StreamData
{
    public string VideoId { get; set; }
    public string ChannelId { get; set; }
    public string ChannelTitle { get; set; }
    public string VideoTitle { get; set; }
    public DateTime ScheduledStartTime { get; set; }
    public string Platform { get; set; }
    // 其他直播相關資訊...
}
```

**批量廣播實作重點**：
- 支援單次接收多個直播狀態變化
- 合併相同 Guild 的多個通知避免訊息洪流
- 使用異步處理避免阻塞主執行緒
- 避免長期持有大量事件資料
- 定期清理處理完成的事件記錄

### 平台監控器介面設計
**[Source: Story 2.3 其他平台爬蟲邏輯遷移]**

**IPlatformMonitor 統一介面**：
```csharp
public interface IPlatformMonitor
{
    string PlatformName { get; }
    Task StartAsync(CancellationToken cancellationToken);
    Task StopAsync(CancellationToken cancellationToken);
    Task<PlatformStatus> GetStatusAsync();
    event EventHandler<StreamStatusChangedEventArgs> StreamStatusChanged;
    
    // 新增動態追蹤控制方法
    Task StartTrackingTargetAsync(string targetIdentifier);
    Task StopTrackingTargetAsync(string targetIdentifier);
    Task UpdateTrackingTargetsAsync(List<string> targets);
}
```

**平台監控器管理**：
- 平台監控器註冊到統一的監控系統
- 平行執行多個平台監控
- 統一的事件廣播格式
- 監控狀態報告

### 外部錄影工具相容性
**[Source: docs/brownfield-architecture.md#外部服務整合]**

**現有事件格式相容性**：
- 維持現有 `streams.online` 和 `streams.offline` 事件名稱
- 保持事件資料結構不變
- 支援現有的 YouTube Stream Record 專案整合
- 確保向後相容性

**事件流程範例**：
```
使用者在 Discord 輸入 `/follow youtube.com/channel/xxx`
    ↓
Discord Shard 驗證 URL 並儲存到資料庫
    ↓  
Discord Shard 透過 PubSub 發送 "stream.follow" 事件
    ↓
Crawler 服務接收事件，開始追蹤該頻道
    ↓
Crawler 檢測到該頻道開台
    ↓
Crawler 透過 PubSub 發送 "streams.online" 事件
    ↓
所有 Discord Shard 接收事件，檢查是否有本地 Guild 需要通知
    ↓
對應 Discord Shard 發送 Discord 通知訊息
```

### 狀態持久化策略
**[Source: docs/brownfield-architecture.md#資料庫整合]**

**資料庫狀態載入**：
- 從 `NoticeYoutubeStreamChannel` 載入 YouTube 追蹤目標
- 從 `NoticeTwitchStreamChannel` 載入 Twitch 追蹤目標  
- 從 `NoticeTwitterSpaceChannel` 載入 Twitter 追蹤目標
- 從 `NoticeTwitCastingStreamChannel` 載入 TwitCasting 追蹤目標

**狀態同步機制**：
- 定期同步記憶體狀態到資料庫避免不一致
- 處理資料庫操作失敗的重試機制
- 服務重啟後從資料庫恢復完整狀態

### 錯誤處理和降級機制
**[Source: Story 1.4 追蹤管理指令 PubSub 整合]**

**常見錯誤場景**：
- Redis 連接失敗：不影響主要功能，記錄錯誤並稍後重試
- 事件序列化錯誤：記錄詳細錯誤信息，檢查資料模型
- 平台 API 調用失敗：向使用者顯示友善錯誤信息

**降級策略**：
```csharp
public async Task PublishFollowEventAsync(StreamFollowEvent followEvent)
{
    try
    {
        if (!await IsRedisAvailableAsync())
        {
            _logger.LogWarning("Redis unavailable, storing event for later retry");
            await StoreEventForRetryAsync(followEvent);
            return;
        }
        
        var json = JsonConvert.SerializeObject(followEvent);
        await _redisConnection.Redis.PublishAsync("stream.follow", json);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to publish follow event, storing for retry");
        await StoreEventForRetryAsync(followEvent);
    }
}
```

### 服務註冊和配置
**[Source: Story 2.1 Crawler 專案架構建立]**

**依賴注入配置**：
```csharp
// Program.cs 中的服務註冊
services.AddSingleton<TrackingManager>();
services.AddHostedService<TrackingEventListener>();
services.AddScoped<EventBroadcastService>();
services.AddScoped<PlatformManager>();
services.AddScoped<TrackingPersistenceService>();

// 配置擴展
public class CrawlerConfig
{
    public TrackingConfig Tracking { get; set; } = new();
}

public class TrackingConfig
{
    public int EventBatchIntervalSeconds { get; set; } = 30;
    public int StateSyncIntervalMinutes { get; set; } = 10;
    public int MaxConcurrentEvents { get; set; } = 100;
    public bool EnableEventBatching { get; set; } = true;
    public bool EnableStateRecovery { get; set; } = true;
}
```

### 效能優化考量
**[Source: Story 1.2 Redis PubSub 事件監聽器建立]**

**記憶體管理**：
- 避免長期持有大量事件資料
- 定期清理處理完成的事件記錄
- 限制同時處理的事件數量

**並發處理**：
- 使用 `ConcurrentDictionary` 和 `ConcurrentHashSet` 進行執行緒安全操作
- 實作背壓處理機制防止記憶體溢出
- 支援非同步事件處理避免阻塞

**資源最佳化**：
- 動態調整 API 調用頻率
- 批量處理減少 PubSub 負載
- 智慧重試和指數退避

### Testing

**單元測試要求**：
- 追蹤管理邏輯測試（新增/移除/計數）
- 事件處理機制測試（序列化/反序列化）
- 動態監控器控制測試
- 批量事件廣播測試
- 狀態持久化和恢復測試

**整合測試要求**：
- 跨服務追蹤管理流程測試
- Redis PubSub 事件流測試
- 資料庫狀態同步測試
- 多平台監控器協調測試

**效能測試要求**：
- 大量追蹤目標管理效能測試
- 批量事件處理效能測試
- 記憶體使用和清理測試
- 並發事件處理壓力測試

**手動測試驗證**：
1. 驗證追蹤計數器的正確性（新增、移除、歸零）
2. 測試動態監控器啟停功能
3. 驗證批量事件廣播機制
4. 測試狀態持久化和服務重啟恢復
5. 驗證外部錄影工具事件相容性
6. 測試錯誤處理和降級機制
7. 驗證效能優化和資源管理
8. 測試多平台監控器協調運作

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | Story 初始建立 | Scrum Master |

## Dev Agent Record

_此區段由開發代理在實作期間填寫_

### Agent Model Used

_待開發代理填寫_

### Debug Log References

_待開發代理填寫_

### Completion Notes List

_待開發代理填寫_

### File List

_待開發代理填寫_

## QA Results

_此區段由 QA 代理在完成故事實作的 QA 審查後填寫_
