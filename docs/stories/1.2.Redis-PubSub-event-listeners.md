# Story 1.2: Redis PubSub 事件監聽器建立

## Status
Draft

## Story
**As a** 系統架構師,
**I want** 建立統一的 Redis PubSub 事件監聽和處理系統,
**so that** Discord Bot 可以接收來自 Crawler 服務的事件並處理跨服務 API 請求

## Acceptance Criteria

1. [ ] 建立 `EventHandlers/StreamEventListener.cs` 監聽直播狀態事件
   - 實作 `streams.online` 事件處理器
   - 實作 `streams.offline` 事件處理器
   - 支援批量事件處理（多個直播同時開關台）
2. [ ] 建立 `EventHandlers/ShardRequestHandler.cs` 處理 Crawler 的 API 請求
   - 監聽 `shard-request:{shardId}` 頻道
   - 實作 Discord API 代理執行機制
   - 支援會員驗證相關的 Guild 操作
3. [ ] 建立事件路由邏輯，根據資料庫通知設定發送通知
   - 查詢資料庫中該平台/頻道的所有通知設定
   - 檢查通知設定對應的 Guild 是否在當前 Shard 中
   - 根據通知設定發送通知到對應 Discord 頻道
4. [ ] 實作事件反序列化和錯誤處理
   - JSON 事件資料反序列化
   - 處理格式錯誤的事件
   - 記錄事件處理失敗的詳細日誌
5. [ ] 建立 Redis 連接管理和重連機制
   - Redis 連接中斷自動重連
   - PubSub 訂閱失敗重試
   - 連接狀態監控

## Tasks / Subtasks

- [ ] Task 1: 建立事件處理基礎架構 (AC: 1, 2)
  - [ ] 建立 `EventHandlers/` 目錄結構
  - [ ] 定義 `IEventHandler` 介面規範
  - [ ] 建立事件資料模型 (`StreamStatusEvent`, `ShardRequestEvent`)
  - [ ] 實作基礎事件處理抽象類別

- [ ] Task 2: 實作 StreamEventListener (AC: 1, 3)
  - [ ] 建立 `EventHandlers/StreamEventListener.cs`
  - [ ] 實作 `streams.online` 事件處理：
    - 反序列化直播開台事件資料
    - 查詢資料庫中該頻道/使用者的所有通知設定
    - 檢查通知設定的 Guild 是否在當前 Shard 中 (`_client.GetGuild()`)
    - 根據通知設定發送 Discord 通知到指定頻道
  - [ ] 實作 `streams.offline` 事件處理：
    - 反序列化直播關台事件資料
    - 執行與 online 事件相同的查詢和通知邏輯
  - [ ] 支援批量事件處理，單次處理多個狀態變化

- [ ] Task 3: 實作 ShardRequestHandler (AC: 2)
  - [ ] 建立 `EventHandlers/ShardRequestHandler.cs`
  - [ ] 監聽 `shard-request:{shardId}` 頻道（shardId 為當前 Shard ID）
  - [ ] 解析請求類型和參數：
    - Guild 角色管理請求
    - 頻道權限檢查請求
    - 會員驗證相關 Discord API 調用
  - [ ] 執行 Discord API 操作並回傳結果
  - [ ] 透過 Redis 發送回應給 Crawler 服務

- [ ] Task 4: 實作事件路由和過濾機制 (AC: 3)
  - [ ] 建立資料庫查詢邏輯：
    - 根據平台和頻道/使用者 ID 查詢對應的 `Notice[Platform]StreamChannel` 表
    - 查詢該頻道/使用者的所有 Guild 通知設定
    - 取得 Discord 通知頻道 ID 和其他設定
  - [ ] 實作 Guild 檢查機制：
    - 使用 `_client.GetGuild(guildId)` 檢查 Guild 是否屬於當前 Shard
    - Guild 不在當前 Shard 時跳過處理（正常情況）
    - 區分「Guild 不在此 Shard」與「Guild 已不存在」的情況
    - 檢查 Discord 頻道權限和存在性
  - [ ] 建立通知發送邏輯：
    - 根據查詢結果發送通知到指定 Discord 頻道
    - 使用現有 Embed 格式 (配合 Story 1.3)
    - 處理權限不足或頻道不存在的錯誤

- [ ] Task 5: 事件資料處理和錯誤處理 (AC: 4)
  - [ ] 實作 JSON 事件反序列化：
    - 定義事件資料結構 (`StreamData`, `ShardRequest`)
    - 使用 Newtonsoft.Json 進行反序列化
    - 處理資料格式驗證
  - [ ] 建立錯誤處理機制：
    - 捕獲和記錄反序列化錯誤
    - 處理 Discord API 調用失敗
    - 實作事件處理失敗的重試邏輯
  - [ ] 建立結構化日誌記錄

- [ ] Task 6: Redis 連接管理 (AC: 5)
  - [ ] 增強現有 `RedisConnection.cs` 的連接管理：
    - 實作自動重連機制
    - 監控連接狀態變化
    - 連接失敗時的告警機制
  - [ ] 實作 PubSub 訂閱管理：
    - 啟動時自動訂閱必要頻道
    - 訂閱失敗時的重試機制
    - 支援動態取消訂閱（服務關閉時）
  - [ ] 建立連接健康檢查

- [ ] Task 7: 服務整合和測試 (AC: 1-5)
  - [ ] 整合事件監聽器到 Bot 主服務：
    - 在 `Bot.cs` 中註冊事件處理器
    - 在 Discord 客戶端 Ready 後啟動事件監聽
    - 確保優雅關閉時停止監聽
  - [ ] 建立 Mock 事件測試機制
  - [ ] 驗證與現有 Discord 指令的相容性

## Dev Notes

### 系統架構轉換背景
**[Source: docs/brownfield-prd.md#FR2-Discord-Shard-重構]**

此 Story 是將 Discord Bot 從單體架構轉換為純事件驅動架構的關鍵步驟。移除爬蟲邏輯後（Story 1.1），Discord Bot 需要透過 Redis PubSub 接收來自未來 Crawler 服務的事件。

### Redis PubSub 頻道規範
**[Source: docs/brownfield-architecture.md#Redis-PubSub-頻道]**

**事件廣播頻道** (Crawler → Discord Shard):
- `streams.online`: 直播開台事件，包含批量直播資料
- `streams.offline`: 直播關台事件，包含批量直播資料
- 保持與外部錄影工具的相容性，維持現有事件格式

**跨服務請求頻道** (Crawler → 特定 Discord Shard):
- `shard-request:{shardId}`: 請求特定 Shard 執行 Discord API 操作
- 用於會員驗證流程中需要 Guild 特定操作的場景
- 支援請求/回應模式的異步通訊

### 事件資料模型

**StreamStatusEvent 結構**:
```csharp
public class StreamStatusEvent
{
    public List<StreamData> Streams { get; set; }
    public bool IsOnline { get; set; }
    public string Platform { get; set; }
    public DateTime Timestamp { get; set; }
    public Dictionary<string, object> Metadata { get; set; }
}

public class StreamData
{
    public string VideoId { get; set; }
    public string ChannelId { get; set; }
    public string ChannelTitle { get; set; }
    public string VideoTitle { get; set; }
    public DateTime ScheduledStartTime { get; set; }
    public string Platform { get; set; }
    // 其他直播相關資訊...
}
```

**ShardRequestEvent 結構**:
```csharp
public class ShardRequestEvent
{
    public string RequestId { get; set; }
    public string Operation { get; set; }
    public ulong GuildId { get; set; }
    public ulong? UserId { get; set; }
    public Dictionary<string, object> Parameters { get; set; }
    public DateTime Timestamp { get; set; }
}

// 支援的操作類型
public static class ShardOperations
{
    public const string CheckGuildMember = "check_guild_member";
    public const string ManageUserRole = "manage_user_role";
    public const string GetChannelPermissions = "get_channel_permissions";
    public const string SendDirectMessage = "send_direct_message";
}
```

### Discord Shard 架構下的 Guild 處理

在 Discord Shard 架構中，每個 Shard 只負責特定範圍的 Guild：
- Guild 分配基於 Discord 算法：`(guild_id >> 22) % total_shards`
- 每個 Shard 只能看到和操作屬於自己的 Guild
- `_client.GetGuild(guildId)` 返回 `null` 通常表示 Guild 不在當前 Shard，而非 Guild 不存在

**事件處理邏輯調整**：
1. 查詢所有平台通知設定（不按 Shard 過濾）
2. 對每個通知設定，檢查對應 Guild 是否在當前 Shard
3. 只處理屬於當前 Shard 的 Guild，其他的靜默跳過
4. 避免錯誤地清理「不在當前 Shard」的通知設定

### Discord Shard 通知處理流程

每個 Discord Shard 在收到直播狀態事件時，應該遵循現有的處理方式：

1. **查詢該頻道/使用者的所有通知設定**：
   - 根據平台和 StreamKey (頻道ID/使用者ID) 查詢資料庫
   - 取得所有設定了該頻道通知的 Guild 清單

2. **檢查 Guild 是否屬於當前 Shard**：
   - 使用 `_client.GetGuild(guildId)` 檢查 Guild 是否存在於當前 Shard
   - 如果 Guild 不在當前 Shard，跳過該通知設定（不是錯誤情況）
   - 只有在確認 Guild 存在但無法訪問時才考慮清理過期設定

3. **發送通知**：
   - 根據通知設定發送通知到指定的 Discord 頻道
   - 使用 Story 1.3 定義的統一 Embed 格式
   - 處理頻道權限和存在性檢查

**與現有 `SendStreamMessageAsync` 的對應關係**：
- 現有方式：查詢 `NoticeYoutubeStreamChannel` → 檢查 `_client.GetGuild()` → 發送通知
- 新的事件監聽方式：相同的查詢和檢查邏輯，只是觸發來源從 Timer 改為 Redis PubSub 事件
- **Shard 架構差異**：現有程式碼在單一實例運行，新架構下每個 Shard 只處理屬於自己的 Guild
- **注意**：`GetGuild()` 返回 `null` 時，在 Shard 架構下通常是正常情況（Guild 在其他 Shard）

### 資料庫查詢實作範例

**參考現有 `SendStreamMessageAsync` 方法**：
```csharp
// 現有的查詢方式 (YouTube 範例)
noticeYoutubeStreamChannels.AddRange(db.NoticeYoutubeStreamChannel.AsNoTracking()
    .Where((x) => x.YouTubeChannelId == streamVideo.ChannelId));

// 對應的新事件監聽器實作
foreach (var streamData in streamEvent.Streams)
{
    List<NoticeYoutubeStreamChannel> notifications;
    using (var db = _dbService.GetDbContext())
    {
        // 查詢該 YouTube 頻道的所有通知設定
        notifications = db.NoticeYoutubeStreamChannel.AsNoTracking()
            .Where(x => x.YouTubeChannelId == streamData.ChannelId)
            .ToList();
    }
    
    // 檢查每個通知設定的 Guild 是否在當前 Shard
    foreach (var notification in notifications)
    {
        var guild = _client.GetGuild(notification.GuildId);
        if (guild == null)
        {
            // Guild 不在當前 Shard，跳過（這是正常情況）
            continue;
        }
        
        // 發送通知 (沿用現有邏輯)
        await SendNotificationToChannel(guild, notification, streamData);
    }
}
```

### 通知處理詳細實作

**StreamEventListener 核心邏輯** (參考現有 `SendStreamMessageAsync`):
```csharp
public class StreamEventListener : IStreamEventListener
{
    private readonly DiscordSocketClient _client;
    private readonly MainDbService _dbService;
    private readonly ILogger<StreamEventListener> _logger;
    
    public async Task HandleStreamOnlineEvent(StreamStatusEvent streamEvent)
    {
        foreach (var streamData in streamEvent.Streams)
        {
            // 根據平台查詢對應的通知設定
            var notifications = await GetNotificationsByPlatform(streamData.Platform, streamData.ChannelId);
            
            // 處理每個通知設定
            foreach (var notification in notifications)
            {
                try
                {
                    // 檢查 Guild 是否屬於當前 Shard (沿用現有邏輯)
                    var guild = _client.GetGuild(notification.GuildId);
                    if (guild == null)
                    {
                        // Guild 不在當前 Shard，跳過處理（這是正常情況）
                        continue;
                    }
                    
                    // 發送通知 (沿用現有邏輯)
                    await SendNotificationToGuild(guild, notification, streamData, isOnline: true);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Failed to process stream notification for Guild {GuildId}", notification.GuildId);
                }
            }
        }
    }
    
    private async Task<List<INotificationSetting>> GetNotificationsByPlatform(string platform, string streamKey)
    {
        using var db = _dbService.GetDbContext();
        
        return platform switch
        {
            "youtube" => db.NoticeYoutubeStreamChannel.AsNoTracking()
                .Where(x => x.YouTubeChannelId == streamKey)
                .Cast<INotificationSetting>()
                .ToList(),
                
            "twitch" => db.NoticeTwitchStreamChannel.AsNoTracking()
                .Where(x => x.UserId == streamKey || x.UserName == streamKey)
                .Cast<INotificationSetting>()
                .ToList(),
                
            "twitter" => db.NoticeTwitterSpaceChannel.AsNoTracking()
                .Where(x => x.UserId == streamKey)
                .Cast<INotificationSetting>()
                .ToList(),
                
            "twitcasting" => db.NoticeTwitCastingStreamChannel.AsNoTracking()
                .Where(x => x.UserId == streamKey)
                .Cast<INotificationSetting>()
                .ToList(),
                
            _ => new List<INotificationSetting>()
        };
    }
    
    private async Task SendNotificationToGuild(SocketGuild guild, INotificationSetting notification, StreamData streamData, bool isOnline)
    {
        // 取得對應的通知頻道 (沿用現有邏輯)
        var channel = guild.GetTextChannel(notification.DiscordChannelId);
        if (channel == null)
        {
            _logger.LogWarning("找不到通知頻道 {ChannelId} in Guild {GuildId}", 
                notification.DiscordChannelId, guild.Id);
            return;
        }
        
        // 檢查權限 (沿用現有邏輯)
        var botUser = guild.GetUser(_client.CurrentUser.Id);
        var permissions = botUser.GetPermissions(channel);
        if (!permissions.SendMessages || !permissions.EmbedLinks)
        {
            _logger.LogWarning("權限不足 in channel {ChannelId} in Guild {GuildId}", 
                channel.Id, guild.Id);
            return;
        }
        
        // 建立並發送通知 Embed (使用 Story 1.3 的格式)
        var embed = CreateStreamNotificationEmbed(streamData, isOnline);
        
        // 取得通知訊息 (沿用現有邏輯)
        string messageText = isOnline ? notification.StartMessage : notification.EndMessage;
        if (messageText == "-") return; // 跳過不發送的設定
        
        await channel.SendMessageAsync(text: messageText, embed: embed);
        
        _logger.LogInformation("Stream notification sent to {ChannelName} in {GuildName} for {StreamTitle}", 
            channel.Name, guild.Name, streamData.VideoTitle);
    }
}
```

### 現有系統整合點

**與 Bot.cs 的整合**:
```csharp
// 在 Bot.cs 的 OnClientReady 事件中
private async Task OnClientReady()
{
    // 現有邏輯...
    
    // 新增：啟動事件監聽器
    _streamEventListener.StartListening();
    _shardRequestHandler.StartListening(_client.ShardId);
    
    Log.Info("事件監聽器已啟動");
}
```

**依賴注入配置更新**:
```csharp
// 在服務註冊中新增
services.AddScoped<IStreamEventListener, StreamEventListener>();
services.AddScoped<IShardRequestHandler, ShardRequestHandler>();
```

### 錯誤處理策略

**Redis 連接錯誤**:
- 連接中斷時記錄 ERROR 級別日誌
- 每 30 秒嘗試重連一次
- 重連成功後重新訂閱所有頻道
- 避免因 Redis 問題導致 Discord Bot 崩潰

**事件處理錯誤**:
- JSON 反序列化失敗：記錄原始訊息內容和錯誤
- Discord API 調用失敗：記錄詳細錯誤信息和重試策略
- Guild 查詢失敗：記錄 Guild ID 和錯誤原因

### 效能考量

**批量事件處理**:
- 支援單次接收多個直播狀態變化
- 合併相同 Guild 的多個通知避免訊息洪流
- 使用異步處理避免阻塞主執行緒

**記憶體管理**:
- 避免長期持有大量事件資料
- 定期清理處理完成的事件記錄
- 限制同時處理的事件數量

### Testing

**單元測試範圍**:
- 事件反序列化邏輯測試
- Guild 路由過濾邏輯測試
- 錯誤處理機制測試
- Mock Redis PubSub 連接測試

**整合測試場景**:
- 模擬 Crawler 發送事件，驗證所有 Guild 的通知處理
- 測試多 Shard 環境下，每個 Shard 只處理屬於自己的 Guild
- 驗證 Guild 不在當前 Shard 時的正確跳過邏輯
- 驗證不同平台的資料庫查詢和通知邏輯
- 測試 Discord 頻道權限不足時的錯誤處理
- 測試 Redis 連接中斷和恢復
- 驗證批量事件處理效能

**手動測試步驟**:
1. 啟動多個 Discord Bot Shard 實例
2. 確保資料庫中有跨多個 Shard 的 Guild 通知設定
3. 手動透過 Redis CLI 發送測試事件
4. 驗證每個 Shard 只處理屬於自己的 Guild 通知
5. 驗證 Guild 不在當前 Shard 時的跳過邏輯
6. 測試錯誤格式事件的處理
7. 測試頻道權限不足的情況處理
8. 驗證 Redis 重連機制

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | Story 初始建立 | Scrum Master |

## Dev Agent Record

_此區段由開發代理在實作期間填寫_

### Agent Model Used

_待開發代理填寫_

### Debug Log References

_待開發代理填寫_

### Completion Notes List

_待開發代理填寫_

### File List

_待開發代理填寫_

## QA Results

_此區段由 QA 代理在完成故事實作的 QA 審查後填寫_
