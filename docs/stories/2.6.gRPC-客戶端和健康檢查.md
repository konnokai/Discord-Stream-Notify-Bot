# Story 2.6: gRPC 客戶端和健康檢查

## Status
Draft

## Story
**As a** 系統架構師,
**I want** 實作 Coordinator 通訊和服務健康檢查機制，完成 Crawler 服務基礎建設,
**so that** Crawler 服務能與 Coordinator 協調運作，並提供完整的健康狀態監控

## Acceptance Criteria

1. [ ] 建立 gRPC 客戶端連接 Coordinator
   - 實作 `CoordinatorGrpcClient.cs`
   - 建立持久化 gRPC 連接
   - 連接失敗自動重試
2. [ ] 實作心跳回報機制（服務狀態、爬蟲計數、API 配額狀態）
   - 定期發送心跳到 Coordinator
   - 報告服務運行狀態
   - 包含監控統計資訊
3. [ ] 建立 HTTP 健康檢查端點 `/health`
   - ASP.NET Core Health Checks
   - 檢查 Redis 連接狀態
   - 檢查資料庫連接狀態
   - 檢查各平台 API 可用性
4. [ ] 實作服務啟動就緒檢查
   - 確保所有依賴服務可用後才報告就緒
   - 支援 Coordinator 啟動順序管理
   - 提供詳細的就緒狀態資訊
5. [ ] 建立優雅關閉機制
   - 接收關閉信號時停止接收新任務
   - 完成現有任務處理
   - 清理資源和連接
   - 向 Coordinator 發送關閉通知

## Tasks / Subtasks

- [ ] Task 1: 建立 gRPC 通訊基礎架構 (AC: 1)
  - [ ] 建立 `Services/CoordinatorGrpcClient.cs` gRPC 客戶端
  - [ ] 定義 `coordinator.proto` gRPC 服務定義（與 Coordinator 同步）：
    ```protobuf
    service Coordinator {
      rpc Heartbeat(HeartbeatRequest) returns (HeartbeatReply);
      rpc ReportStatus(StatusReportRequest) returns (StatusReportReply);
      rpc RegisterService(ServiceRegistrationRequest) returns (ServiceRegistrationReply);
      rpc NotifyShutdown(ShutdownNotificationRequest) returns (ShutdownNotificationReply);
    }
    ```
  - [ ] 實作 gRPC 客戶端連接管理：
    - 建立持久化 gRPC Channel
    - 連接失敗自動重試（指數退避）
    - 連接狀態監控和日誌記錄
  - [ ] 建立 gRPC 相關資料模型和訊息類型
  - [ ] 在依賴注入中註冊 gRPC 客戶端服務

- [ ] Task 2: 實作心跳回報系統 (AC: 2)
  - [ ] 建立 `Services/HeartbeatService.cs` 背景服務
  - [ ] 實作定期心跳機制：
    - 每 30 秒向 Coordinator 發送心跳
    - 包含服務運行狀態（啟動時間、版本、程序 ID）
    - 報告當前監控的直播數量
    - 各平台 API 配額使用情況
  - [ ] 實作服務統計資訊收集：
    - 監控中的 YouTube/Twitch/Twitter/TwitCasting 目標數量
    - API 調用次數和配額狀態
    - 錯誤統計和成功率
    - 記憶體和 CPU 使用情況
  - [ ] 建立心跳失敗處理：
    - 心跳發送失敗重試機制
    - Coordinator 無回應時的處理
    - 網路分割情況下的降級策略
  - [ ] 實作優雅關閉時的最後心跳通知

- [ ] Task 3: 建立健康檢查端點 (AC: 3)
  - [ ] 建立 `HealthChecks/CrawlerHealthCheck.cs` 主健康檢查
  - [ ] 實作各項依賴服務健康檢查：
    - Redis 連接狀態檢查（測試 PING 指令）
    - 資料庫連接狀態檢查（執行簡單查詢）
    - 各平台 API 可用性檢查（輕量級 API 呼叫）
  - [ ] 建立 `HealthChecks/PlatformApiHealthCheck.cs` 平台 API 檢查：
    - YouTube Data API 可用性和配額狀態
    - Twitch API 可用性檢查
    - Twitter API 連接狀態（考慮其不穩定性）
    - TwitCasting API 狀態檢查
  - [ ] 實作健康檢查聚合和報告：
    - 整體健康狀態計算
    - 詳細的子系統狀態報告
    - 健康檢查性能監控
  - [ ] 配置 ASP.NET Core 健康檢查中介軟體：
    - 暴露 `/health` 端點
    - 支援 JSON 格式回應
    - 配置健康檢查逾時和間隔

- [ ] Task 4: 實作啟動就緒檢查機制 (AC: 4)
  - [ ] 建立 `Services/ReadinessService.cs` 啟動就緒管理
  - [ ] 實作依賴服務就緒檢查：
    - 等待 Redis 連接建立
    - 等待資料庫連接和初始化完成
    - 等待各平台監控器初始化
    - 等待 gRPC 客戶端連接到 Coordinator
  - [ ] 建立啟動階段管理：
    - `Starting` - 服務啟動中
    - `Initializing` - 依賴服務初始化中
    - `Ready` - 所有服務就緒，可接受請求
    - `Degraded` - 部分服務不可用
  - [ ] 實作就緒狀態回報：
    - 向 Coordinator 回報就緒狀態變化
    - 提供詳細的就緒檢查結果
    - 支援 Coordinator 的啟動順序控制
  - [ ] 建立啟動逾時和錯誤處理：
    - 啟動逾時後進入降級模式
    - 依賴服務不可用時的處理策略

- [ ] Task 5: 實作優雅關閉機制 (AC: 5)
  - [ ] 建立 `Services/GracefulShutdownService.cs` 關閉管理
  - [ ] 實作關閉信號處理：
    - 監聽 SIGTERM 和 SIGINT 信號
    - 接收關閉信號後立即停止接收新任務
    - 設定關閉逾時（預設 30 秒）
  - [ ] 實作服務關閉順序：
    - 1. 停止心跳服務和新任務接收
    - 2. 等待現有監控任務完成
    - 3. 關閉平台監控器和 API 連接
    - 4. 關閉資料庫和 Redis 連接
    - 5. 向 Coordinator 發送關閉通知
  - [ ] 建立強制關閉機制：
    - 超過逾時時間後強制終止
    - 記錄未完成的任務
    - 清理暫存檔案和資源
  - [ ] 實作關閉狀態回報和日誌記錄：
    - 詳細記錄關閉過程
    - 向 Coordinator 回報關閉狀態
    - 生成關閉摘要報告

- [ ] Task 6: 整合 Coordinator 通訊協定 (AC: 1, 2, 4, 5)
  - [ ] 實作服務註冊流程：
    - 啟動時向 Coordinator 註冊服務實例
    - 提供服務基本資訊（名稱、版本、端點）
    - 接收 Coordinator 分配的服務 ID
  - [ ] 實作狀態回報機制：
    - 定期回報詳細服務狀態
    - 包含效能指標和統計資訊
    - 支援 Coordinator 的監控需求
  - [ ] 建立指令接收機制：
    - 接收 Coordinator 的管理指令（重啟、停止）
    - 實作指令執行和結果回報
    - 支援配置熱重載指令
  - [ ] 實作錯誤回報機制：
    - 關鍵錯誤即時通知 Coordinator
    - 提供錯誤上下文和堆疊資訊
    - 支援錯誤統計和趨勢分析

- [ ] Task 7: 建立監控和統計系統 (AC: 2, 3)
  - [ ] 建立 `Services/MetricsCollectionService.cs` 統計收集
  - [ ] 實作效能指標收集：
    - CPU 和記憶體使用情況
    - GC 和執行緒池統計
    - HTTP 請求和回應時間
    - gRPC 調用統計
  - [ ] 實作業務指標收集：
    - 各平台監控目標數量
    - API 調用成功率和錯誤率
    - 事件處理統計
    - 追蹤管理操作統計
  - [ ] 建立指標聚合和報告：
    - 即時指標儀表板
    - 歷史趨勢分析
    - 異常檢測和告警
  - [ ] 實作指標暴露機制：
    - 透過健康檢查端點暴露
    - 支援 Prometheus 格式（可選）
    - 透過心跳回報給 Coordinator

- [ ] Task 8: 配置管理和服務整合 (AC: 1-5)
  - [ ] 擴展 Crawler 配置支援 gRPC 和健康檢查設定：
    ```yaml
    coordinator:
      grpc_endpoint: "localhost:50051"
      heartbeat_interval_seconds: 30
      connection_timeout_seconds: 10
      max_retry_attempts: 5
      
    health_checks:
      enabled: true
      endpoint: "/health"
      detailed_response: true
      timeout_seconds: 30
      
    graceful_shutdown:
      timeout_seconds: 30
      force_kill_after_seconds: 45
    ```
  - [ ] 建立 gRPC 和健康檢查相關服務依賴注入：
    - 註冊 gRPC 客戶端和連接管理
    - 註冊健康檢查服務和提供者
    - 註冊心跳和就緒檢查服務
  - [ ] 實作配置驗證和初始化：
    - 啟動時驗證 gRPC 和健康檢查配置
    - 提供配置項目說明和範例
    - 支援環境變數覆蓋配置

- [ ] Task 9: 建立測試和驗證 (AC: 1-5)
  - [ ] 建立 gRPC 客戶端通訊測試：
    - Mock Coordinator gRPC 服務
    - 測試連接建立和重試機制
    - 驗證心跳和狀態回報功能
  - [ ] 建立健康檢查功能測試：
    - 測試各依賴服務的健康檢查
    - 模擬服務不可用情況
    - 驗證健康檢查聚合邏輯
  - [ ] 建立啟動和關閉流程測試：
    - 測試服務啟動就緒檢查
    - 驗證優雅關閉機制
    - 測試強制關閉情況處理
  - [ ] 建立效能和負載測試：
    - gRPC 通訊效能測試
    - 健康檢查回應時間測試
    - 心跳機制穩定性測試
  - [ ] 建立整合測試：
    - 與實際 Coordinator 服務的通訊測試
    - 端到端的服務生命週期測試
    - 故障恢復和容錯能力測試

## Dev Notes

### 前一個故事的關鍵洞察
**[Source: Story 2.5 事件廣播和追蹤管理系統]**

前一個故事建立了事件廣播和追蹤管理的核心機制：
- `TrackingManager.cs` - 全域追蹤計數器管理
- `EventBroadcastService.cs` - 批量事件廣播機制
- `PlatformManager.cs` - 動態平台監控管理

這些服務的健康狀態和統計資訊將成為本故事中健康檢查和心跳回報的重要內容。

### Coordinator 通訊架構
**[Source: docs/brownfield-architecture.md#服務間通訊模式]**

**服務間通訊協定**：
- **Coordinator ↔ Services**：gRPC 雙向通訊（心跳、狀態查詢、重啟指令）
- **Crawler ↔ Discord Shard**：Redis PubSub 單向事件通知
- **Services ↔ Database**：直接 MySQL 連接，各服務獨立管理連接池

### gRPC 服務定義
**[Source: docs/epic-stories.md#Story 3.1 Coordinator gRPC 服務建立]**

**coordinator.proto 定義**：
```protobuf
syntax = "proto3";

option csharp_namespace = "StreamNotifyBot.Coordinator.Grpc";
package coordinator;

service Coordinator {
    rpc Heartbeat(HeartbeatRequest) returns (HeartbeatReply);
    rpc GetStatus(GetStatusRequest) returns (GetStatusReply);
    rpc GetAllStatuses(GetAllStatusesRequest) returns (GetAllStatusesReply);
    rpc RestartService(RestartServiceRequest) returns (RestartServiceReply);
    rpc RegisterService(ServiceRegistrationRequest) returns (ServiceRegistrationReply);
    rpc NotifyShutdown(ShutdownNotificationRequest) returns (ShutdownNotificationReply);
}

message HeartbeatRequest {
    string service_id = 1;
    string service_name = 2;
    int64 timestamp = 3;
    ServiceStatus status = 4;
    repeated MetricData metrics = 5;
}

message HeartbeatReply {
    bool success = 1;
    string message = 2;
    repeated ServiceCommand commands = 3;
}

message ServiceStatus {
    string status = 1; // "healthy", "degraded", "unhealthy"
    string uptime = 2;
    string version = 3;
    int32 process_id = 4;
    repeated SubSystemStatus subsystems = 5;
}

message MetricData {
    string name = 1;
    string value = 2;
    string unit = 3;
    int64 timestamp = 4;
}

message SubSystemStatus {
    string name = 1;
    string status = 2;
    string details = 3;
}

message ServiceCommand {
    string command = 1; // "restart", "shutdown", "reload_config"
    map<string, string> parameters = 2;
}

message ServiceRegistrationRequest {
    string service_name = 1;
    string service_version = 2;
    string endpoint = 3;
    repeated string capabilities = 4;
}

message ServiceRegistrationReply {
    bool success = 1;
    string service_id = 2;
    string message = 3;
}

message ShutdownNotificationRequest {
    string service_id = 1;
    string reason = 2;
    int64 timestamp = 3;
}

message ShutdownNotificationReply {
    bool acknowledged = 1;
    string message = 2;
}
```

### gRPC 客戶端實作設計

**CoordinatorGrpcClient 架構**：
```csharp
public interface ICoordinatorGrpcClient
{
    Task<string> RegisterServiceAsync(ServiceRegistrationRequest request);
    Task<bool> SendHeartbeatAsync(HeartbeatRequest request);
    Task<bool> NotifyShutdownAsync(ShutdownNotificationRequest request);
    Task<bool> IsConnectedAsync();
    event EventHandler<ServiceCommand> CommandReceived;
}

public class CoordinatorGrpcClient : ICoordinatorGrpcClient, IDisposable
{
    private readonly GrpcChannel _channel;
    private readonly Coordinator.CoordinatorClient _client;
    private readonly ILogger<CoordinatorGrpcClient> _logger;
    private readonly Timer _reconnectionTimer;
    private volatile bool _isConnected = false;
    
    public CoordinatorGrpcClient(IConfiguration configuration, ILogger<CoordinatorGrpcClient> logger)
    {
        var coordinatorEndpoint = configuration["Coordinator:GrpcEndpoint"];
        
        _channel = GrpcChannel.ForAddress(coordinatorEndpoint, new GrpcChannelOptions
        {
            HttpHandler = new SocketsHttpHandler
            {
                PooledConnectionIdleTimeout = TimeSpan.FromMinutes(2),
                KeepAlivePingDelay = TimeSpan.FromSeconds(30),
                KeepAlivePingTimeout = TimeSpan.FromSeconds(5),
                EnableMultipleHttp2Connections = true
            }
        });
        
        _client = new Coordinator.CoordinatorClient(_channel);
        _logger = logger;
        
        // 重連機制
        _reconnectionTimer = new Timer(CheckConnectionAsync, null, 
            TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
    }
    
    public async Task<string> RegisterServiceAsync(ServiceRegistrationRequest request)
    {
        try
        {
            var response = await _client.RegisterServiceAsync(request, 
                deadline: DateTime.UtcNow.AddSeconds(10));
                
            if (response.Success)
            {
                _isConnected = true;
                _logger.LogInformation("Service registered with ID: {ServiceId}", response.ServiceId);
                return response.ServiceId;
            }
            else
            {
                _logger.LogError("Service registration failed: {Message}", response.Message);
                return null;
            }
        }
        catch (RpcException ex) when (ex.StatusCode == StatusCode.Unavailable)
        {
            _logger.LogWarning("Coordinator unavailable during registration");
            _isConnected = false;
            return null;
        }
    }
    
    public async Task<bool> SendHeartbeatAsync(HeartbeatRequest request)
    {
        try
        {
            var response = await _client.HeartbeatAsync(request, 
                deadline: DateTime.UtcNow.AddSeconds(5));
                
            if (response.Success)
            {
                _isConnected = true;
                
                // 處理 Coordinator 指令
                foreach (var command in response.Commands)
                {
                    CommandReceived?.Invoke(this, command);
                }
                
                return true;
            }
            
            return false;
        }
        catch (RpcException ex)
        {
            _logger.LogWarning("Heartbeat failed: {Status} - {Message}", ex.StatusCode, ex.Message);
            _isConnected = false;
            return false;
        }
    }
    
    private async void CheckConnectionAsync(object state)
    {
        if (!_isConnected)
        {
            _logger.LogInformation("Attempting to reconnect to Coordinator...");
            // 實作重連邏輯
        }
    }
}
```

### 健康檢查系統設計

**CrawlerHealthCheck 詳細實作**：
```csharp
public class CrawlerHealthCheck : IHealthCheck
{
    private readonly RedisConnection _redisConnection;
    private readonly MainDbService _dbService;
    private readonly IEnumerable<IPlatformMonitor> _platformMonitors;
    private readonly ICoordinatorGrpcClient _coordinatorClient;
    private readonly ILogger<CrawlerHealthCheck> _logger;
    
    public async Task<HealthCheckResult> CheckHealthAsync(
        HealthCheckContext context, 
        CancellationToken cancellationToken = default)
    {
        var healthData = new Dictionary<string, object>();
        var overallHealthy = true;
        var issues = new List<string>();
        
        // 檢查 Redis 連接
        var redisHealthy = await CheckRedisHealthAsync();
        healthData["redis"] = new { 
            status = redisHealthy ? "healthy" : "unhealthy",
            connection_state = _redisConnection.Redis?.IsConnected ?? false
        };
        if (!redisHealthy)
        {
            overallHealthy = false;
            issues.Add("Redis connection is unavailable");
        }
        
        // 檢查資料庫連接
        var dbHealthy = await CheckDatabaseHealthAsync();
        healthData["database"] = new { 
            status = dbHealthy ? "healthy" : "unhealthy"
        };
        if (!dbHealthy)
        {
            overallHealthy = false;
            issues.Add("Database connection is unavailable");
        }
        
        // 檢查平台監控器狀態
        var platformStatus = new Dictionary<string, object>();
        foreach (var monitor in _platformMonitors)
        {
            try
            {
                var status = await monitor.GetStatusAsync();
                platformStatus[monitor.PlatformName] = new {
                    status = status.IsHealthy ? "healthy" : "degraded",
                    monitored_count = status.MonitoredStreamCount,
                    last_check = status.LastCheckTime,
                    api_quota = status.ApiQuotaUsage
                };
            }
            catch (Exception ex)
            {
                platformStatus[monitor.PlatformName] = new {
                    status = "error",
                    error = ex.Message
                };
                overallHealthy = false;
                issues.Add($"{monitor.PlatformName} monitor is unhealthy");
            }
        }
        healthData["platforms"] = platformStatus;
        
        // 檢查 Coordinator 連接
        var coordinatorHealthy = await _coordinatorClient.IsConnectedAsync();
        healthData["coordinator"] = new { 
            status = coordinatorHealthy ? "connected" : "disconnected"
        };
        // Coordinator 斷線不影響整體健康狀態（降級運行）
        
        // 系統資源檢查
        var memoryUsage = GC.GetTotalMemory(false);
        var workingSet = Environment.WorkingSet;
        healthData["system"] = new {
            memory_usage_mb = memoryUsage / 1024 / 1024,
            working_set_mb = workingSet / 1024 / 1024,
            processor_count = Environment.ProcessorCount,
            uptime = Environment.TickCount64 / 1000 / 60 // 分鐘
        };
        
        var status = overallHealthy ? HealthStatus.Healthy : HealthStatus.Unhealthy;
        var description = overallHealthy 
            ? "Crawler service is healthy" 
            : $"Crawler service has issues: {string.Join(", ", issues)}";
            
        return new HealthCheckResult(status, description, data: healthData);
    }
    
    private async Task<bool> CheckRedisHealthAsync()
    {
        try
        {
            if (_redisConnection?.Redis == null || !_redisConnection.Redis.IsConnected)
                return false;
                
            await _redisConnection.Redis.PingAsync();
            return true;
        }
        catch
        {
            return false;
        }
    }
    
    private async Task<bool> CheckDatabaseHealthAsync()
    {
        try
        {
            using var db = _dbService.GetDbContext();
            await db.Database.ExecuteSqlRawAsync("SELECT 1");
            return true;
        }
        catch
        {
            return false;
        }
    }
}
```

### 心跳回報服務設計

**HeartbeatService 實作**：
```csharp
public class HeartbeatService : BackgroundService
{
    private readonly ICoordinatorGrpcClient _coordinatorClient;
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<HeartbeatService> _logger;
    private readonly CrawlerConfig _config;
    private string _serviceId;
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // 服務註冊
        _serviceId = await RegisterWithCoordinatorAsync();
        if (string.IsNullOrEmpty(_serviceId))
        {
            _logger.LogError("Failed to register with Coordinator, running in standalone mode");
        }
        
        var heartbeatInterval = TimeSpan.FromSeconds(_config.Coordinator.HeartbeatIntervalSeconds);
        
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await SendHeartbeatAsync();
                await Task.Delay(heartbeatInterval, stoppingToken);
            }
            catch (OperationCanceledException)
            {
                break; // 正常關閉
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in heartbeat service");
                await Task.Delay(TimeSpan.FromSeconds(10), stoppingToken); // 錯誤後短暫等待
            }
        }
    }
    
    private async Task<string> RegisterWithCoordinatorAsync()
    {
        var registrationRequest = new ServiceRegistrationRequest
        {
            ServiceName = "StreamNotifyBot.Crawler",
            ServiceVersion = GetAssemblyVersion(),
            Endpoint = GetServiceEndpoint(),
            Capabilities = { "youtube_monitoring", "twitch_monitoring", "twitter_monitoring", "twitcasting_monitoring" }
        };
        
        return await _coordinatorClient.RegisterServiceAsync(registrationRequest);
    }
    
    private async Task SendHeartbeatAsync()
    {
        if (string.IsNullOrEmpty(_serviceId)) return;
        
        // 收集服務狀態
        var serviceStatus = await CollectServiceStatusAsync();
        
        // 收集監控指標
        var metrics = await CollectMetricsAsync();
        
        var heartbeatRequest = new HeartbeatRequest
        {
            ServiceId = _serviceId,
            ServiceName = "crawler",
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            Status = serviceStatus,
            Metrics = { metrics }
        };
        
        var success = await _coordinatorClient.SendHeartbeatAsync(heartbeatRequest);
        if (!success)
        {
            _logger.LogWarning("Failed to send heartbeat to Coordinator");
        }
    }
    
    private async Task<ServiceStatus> CollectServiceStatusAsync()
    {
        // 使用健康檢查服務收集狀態
        using var scope = _serviceProvider.CreateScope();
        var healthCheckService = scope.ServiceProvider.GetRequiredService<HealthCheckService>();
        
        var healthReport = await healthCheckService.CheckHealthAsync();
        
        var subSystemStatuses = healthReport.Entries.Select(entry => new SubSystemStatus
        {
            Name = entry.Key,
            Status = entry.Value.Status.ToString().ToLowerInvariant(),
            Details = entry.Value.Description
        }).ToList();
        
        return new ServiceStatus
        {
            Status = healthReport.Status.ToString().ToLowerInvariant(),
            Uptime = Environment.TickCount64.ToString(),
            Version = GetAssemblyVersion(),
            ProcessId = Environment.ProcessId,
            Subsystems = { subSystemStatuses }
        };
    }
    
    private async Task<List<MetricData>> CollectMetricsAsync()
    {
        var metrics = new List<MetricData>();
        
        // 系統指標
        metrics.Add(new MetricData
        {
            Name = "memory_usage_mb",
            Value = (GC.GetTotalMemory(false) / 1024 / 1024).ToString(),
            Unit = "MB",
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });
        
        // 業務指標 - 透過服務收集
        using var scope = _serviceProvider.CreateScope();
        var trackingManager = scope.ServiceProvider.GetService<TrackingManager>();
        if (trackingManager != null)
        {
            var trackingStats = await trackingManager.GetStatisticsAsync();
            metrics.Add(new MetricData
            {
                Name = "tracked_streams_count",
                Value = trackingStats.TotalTrackedStreams.ToString(),
                Unit = "count",
                Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            });
        }
        
        return metrics;
    }
}
```

### 優雅關閉機制設計

**GracefulShutdownService 實作**：
```csharp
public class GracefulShutdownService : IHostedService
{
    private readonly IHostApplicationLifetime _appLifetime;
    private readonly ICoordinatorGrpcClient _coordinatorClient;
    private readonly ILogger<GracefulShutdownService> _logger;
    private readonly CrawlerConfig _config;
    private string _serviceId;
    
    public Task StartAsync(CancellationToken cancellationToken)
    {
        _appLifetime.ApplicationStopping.Register(OnStopping);
        _appLifetime.ApplicationStopped.Register(OnStopped);
        return Task.CompletedTask;
    }
    
    private void OnStopping()
    {
        _logger.LogInformation("Application is stopping - beginning graceful shutdown");
        
        try
        {
            // 1. 立即停止接收新任務
            StopAcceptingNewTasks();
            
            // 2. 等待現有任務完成
            var shutdownTimeout = TimeSpan.FromSeconds(_config.GracefulShutdown.TimeoutSeconds);
            var completed = WaitForTasksToComplete(shutdownTimeout);
            
            if (!completed)
            {
                _logger.LogWarning("Some tasks did not complete within timeout, proceeding with shutdown");
            }
            
            // 3. 通知 Coordinator
            NotifyCoordinatorOfShutdown("Graceful shutdown requested").Wait(TimeSpan.FromSeconds(5));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during graceful shutdown");
        }
    }
    
    private void OnStopped()
    {
        _logger.LogInformation("Application stopped");
    }
    
    private void StopAcceptingNewTasks()
    {
        // 停止所有背景服務接收新任務
        // 這裡需要與其他服務協調
    }
    
    private bool WaitForTasksToComplete(TimeSpan timeout)
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        while (stopwatch.Elapsed < timeout)
        {
            if (AreAllTasksCompleted())
            {
                return true;
            }
            
            Thread.Sleep(1000); // 檢查間隔
        }
        
        return false;
    }
    
    private bool AreAllTasksCompleted()
    {
        // 檢查所有關鍵任務是否完成
        // 實作具體的任務完成檢查邏輯
        return true;
    }
    
    private async Task NotifyCoordinatorOfShutdown(string reason)
    {
        if (string.IsNullOrEmpty(_serviceId) || _coordinatorClient == null)
            return;
            
        try
        {
            var shutdownRequest = new ShutdownNotificationRequest
            {
                ServiceId = _serviceId,
                Reason = reason,
                Timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            };
            
            await _coordinatorClient.NotifyShutdownAsync(shutdownRequest);
            _logger.LogInformation("Notified Coordinator of shutdown");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to notify Coordinator of shutdown");
        }
    }
}
```

### 服務配置和註冊

**Program.cs 中的服務註冊**：
```csharp
// gRPC 客戶端註冊
services.AddSingleton<ICoordinatorGrpcClient, CoordinatorGrpcClient>();

// 健康檢查服務
services.AddHealthChecks()
    .AddCheck<CrawlerHealthCheck>("crawler")
    .AddCheck<PlatformApiHealthCheck>("platform_apis");

// 背景服務註冊
services.AddHostedService<HeartbeatService>();
services.AddHostedService<GracefulShutdownService>();

// 健康檢查端點配置
app.MapHealthChecks("/health", new HealthCheckOptions
{
    ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse,
    ResultStatusCodes = new Dictionary<HealthStatus, int>
    {
        [HealthStatus.Healthy] = StatusCodes.Status200OK,
        [HealthStatus.Degraded] = StatusCodes.Status200OK,
        [HealthStatus.Unhealthy] = StatusCodes.Status503ServiceUnavailable
    }
});
```

### 配置結構

**appsettings.json 範例**：
```json
{
  "Coordinator": {
    "GrpcEndpoint": "https://localhost:50051",
    "HeartbeatIntervalSeconds": 30,
    "ConnectionTimeoutSeconds": 10,
    "MaxRetryAttempts": 5
  },
  "HealthChecks": {
    "Enabled": true,
    "Endpoint": "/health",
    "DetailedResponse": true,
    "TimeoutSeconds": 30
  },
  "GracefulShutdown": {
    "TimeoutSeconds": 30,
    "ForceKillAfterSeconds": 45
  }
}
```

### 錯誤處理和降級策略

**常見錯誤場景處理**：
- **Coordinator 不可用**：進入獨立模式，繼續提供核心功能
- **健康檢查超時**：回報部分狀態，標記為降級
- **gRPC 連接失敗**：自動重試，記錄詳細錯誤信息
- **心跳發送失敗**：重試機制，避免頻繁重連

### Testing

**單元測試要求**：
- gRPC 客戶端連接和重試機制測試
- 健康檢查各子系統狀態測試
- 心跳資料收集和發送測試
- 優雅關閉流程測試

**整合測試要求**：
- 與 Mock Coordinator 的完整通訊測試
- 健康檢查端點的 HTTP 測試
- 服務註冊和狀態回報流程測試
- 故障恢復和降級模式測試

**效能測試要求**：
- gRPC 通訊延遲和吞吐量測試
- 健康檢查回應時間測試
- 心跳機制穩定性測試
- 資源使用效率測試

**手動測試驗證**：
1. 驗證服務註冊和心跳機制
2. 測試健康檢查端點各種狀態回報
3. 驗證優雅關閉流程
4. 測試 Coordinator 斷線後的自動重連
5. 驗證各依賴服務故障時的降級行為
6. 測試服務統計資訊收集的正確性

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | Story 初始建立 | Scrum Master |

## Dev Agent Record

_此區段由開發代理在實作期間填寫_

### Agent Model Used

_待開發代理填寫_

### Debug Log References

_待開發代理填寫_

### Completion Notes List

_待開發代理填寫_

### File List

_待開發代理填寫_

## QA Results

_此區段由 QA 代理在完成故事實作的 QA 審查後填寫_
