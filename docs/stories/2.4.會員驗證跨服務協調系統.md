````markdown
# Story 2.4: 會員驗證跨服務協調系統

## Status
Draft

## Story
**As a** 系統架構師,
**I want** 實作會員驗證邏輯和 Discord Shard 路由機制，確保正確的跨服務協調,
**so that** 會員驗證功能能在分散式架構下正常運作，透過正確的 Shard 執行 Discord API 操作

## Acceptance Criteria

1. [ ] 建立 `MemberVerification/MemberVerificationService.cs`
   - 從 Discord Bot 遷移所有會員驗證邏輯
   - OAuth2 token 管理和續期
   - 定時驗證任務調度
2. [ ] 實作 shard 路由計算：`(guild_id >> 22) % total_shards`
   - 建立 `ShardRoutingService.cs`
   - Guild ID 到 Shard ID 的映射計算
   - 支援動態 Shard 數量調整
3. [ ] 建立 `public class MemberVerificationConfig
{
    public int NewMemberVerificationIntervalMinutes { get; set; } = 5;      // 新會員驗證間隔
    public int OldMemberVerificationHour { get; set; } = 4;                // 舊會員驗證執行時間（半夜 4 點）
    public int OldMemberSplitDays { get; set; } = 3;                       // 舊會員驗證分割天數
    public string MemberCheckProgressFile { get; set; } = "MemberCheck.dat"; // 進度檔案名稱
    public int ShardRequestTimeoutSeconds { get; set; } = 30;
    public int MaxRetryAttempts { get; set; } = 3;
    public bool EnableVerificationCache { get; set; } = true;
    public int CacheExpirationMinutes { get; set; } = 360;
}quest:{shardId}` PubSub 請求機制
   - 實作請求/回應模式
   - 支援異步等待回應
   - 請求超時處理
   - 重試失敗請求
4. [ ] 實作 OAuth2 token 集中管理和自動續期
   - Token 儲存和加密
   - 自動續期檢查
   - 過期 token 處理
   - 使用者授權狀態管理
5. [ ] 建立會員驗證定時任務和狀態追蹤
   - 新會員驗證：每 5 分鐘執行一次
   - 舊會員驗證：每天半夜 4 點執行，三段式分割機制
   - 批量會員驗證處理
   - 驗證結果快取（格式：`{userId}_{youtubeChannelId}`）
   - 狀態變化追蹤
   - 驗證失敗處理
6. [ ] 實作 Discord API 操作代理機制
   - 透過正確 Shard 執行 Guild 操作
   - 支援角色管理、權限檢查、Guild/頻道/角色查詢
   - 支援多種訊息發送操作（普通、錯誤、確認、Embed、私訊）
   - 支援發送給 Bot 擁有者的錯誤通知
   - Discord API 異常處理和自動重試
   - API 調用結果回傳

## Tasks / Subtasks

- [ ] Task 1: 建立 Shard 路由計算服務 (AC: 2)
  - [ ] 建立 `Services/ShardRoutingService.cs` 實作 Guild ID 到 Shard ID 映射
  - [ ] 實作 Discord 標準 shard 計算算法：`(guild_id >> 22) % total_shards`
  - [ ] 建立動態 Shard 數量調整機制，支援 `BaseDiscordClient.GetRecommendedShardCountAsync()` 結果
  - [ ] 實作 shard 狀態追蹤和健康檢查
  - [ ] 建立 shard 路由配置管理和驗證

- [ ] Task 2: 實作 Redis PubSub 請求/回應模式 (AC: 3)
  - [ ] 建立 `Services/ShardRequestService.cs` 管理跨服務 API 請求
  - [ ] 實作請求/回應模式：`shard-request:{shardId}` 請求頻道和 `shard-response:{requestId}` 回應頻道
  - [ ] 建立異步等待機制，支援超時控制（預設 30 秒）
  - [ ] 實作請求失敗重試邏輯（指數退避，最多 3 次重試）
  - [ ] 建立請求追蹤和日誌記錄

- [ ] Task 3: 遷移會員驗證核心邏輯 (AC: 1, 5)
  - [ ] 從 `SharedService/YoutubeMember/YoutubeMemberService.cs` 遷移會員驗證邏輯到 `MemberVerification/MemberVerificationService.cs`
  - [ ] 遷移 `CheckMemberShip()` 定時驗證方法和相關輔助方法
  - [ ] 實作批量會員驗證處理，優化資料庫查詢效能
  - [ ] 建立會員驗證結果快取機制，使用格式 `{userId}_{youtubeChannelId}` 減少重複驗證
  - [ ] 實作驗證狀態變化追蹤和通知

- [ ] Task 4: 實作 OAuth2 Token 管理系統 (AC: 4)
  - [ ] 建立 `Auth/TokenManagerService.cs` 集中管理 OAuth2 tokens
  - [ ] 遷移現有 `Auth/TokenManager.cs` 和 `Auth/TokenCrypto.cs` 加密邏輯
  - [ ] 實作自動 token 續期檢查機制（每小時檢查一次）
  - [ ] 建立過期 token 處理流程和使用者通知
  - [ ] 實作使用者授權狀態管理和撤銷處理
  - [ ] 整合 `member.revokeToken` Redis 事件監聽

- [ ] Task 5: 建立 Discord API 操作代理 (AC: 6)
  - [ ] 建立 `Services/DiscordApiProxyService.cs` 代理 Discord API 操作
  - [ ] 實作 Guild 和頻道查詢操作：
    - `GetGuildAsync(guildId)` - 獲取 Guild 資訊
    - `GetTextChannelAsync(guildId, channelId)` - 獲取文字頻道
    - `GetRoleAsync(guildId, roleId)` - 獲取角色資訊
    - `CheckGuildExistsAsync(guildId)` - 檢查 Guild 是否存在
  - [ ] 實作 Guild 成員角色管理操作：
    - `AddRoleToMemberAsync(guildId, userId, roleId)` - 新增角色
    - `RemoveRoleFromMemberAsync(guildId, userId, roleId)` - 移除角色
    - `GetGuildMemberAsync(guildId, userId)` - 獲取成員資訊
  - [ ] 實作權限檢查操作：
    - `CheckBotPermissionsAsync(guildId)` - 檢查 Bot 伺服器權限（ManageRoles）
    - `CheckChannelPermissionsAsync(guildId, channelId)` - 檢查頻道權限（ViewChannel, SendMessages, EmbedLinks）
    - `CheckRoleValidityAsync(guildId, roleId)` - 檢查角色是否為 Everyone 角色
  - [ ] 實作訊息發送操作：
    - `SendChannelMessageAsync(guildId, channelId, message)` - 發送普通訊息
    - `SendChannelErrorMessageAsync(guildId, channelId, userId, channelTitle, errorMsg)` - 發送錯誤訊息
    - `SendChannelConfirmMessageAsync(guildId, channelId, title, description)` - 發送確認訊息
    - `SendChannelEmbedMessageAsync(guildId, channelId, embedBuilder)` - 發送 Embed 訊息
  - [ ] 實作私訊發送操作：
    - `SendUserErrorMessageAsync(userId, message, logChannelId)` - 發送使用者錯誤私訊
    - `SendUserConfirmMessageAsync(userId, message, logChannelId)` - 發送使用者確認私訊
    - `SendOwnerErrorMessageAsync(message, logChannelId)` - 發送給 Bot 擁有者的錯誤訊息
  - [ ] 建立 API 調用結果回傳和錯誤處理機制：
    - Discord API 異常處理（權限不足、使用者不存在、Guild 不存在等）
    - 自動重試機制
    - 詳細錯誤日誌記錄
  - [ ] 實作 API 調用日誌和統計

- [ ] Task 6: 整合會員驗證定時任務 (AC: 5)
  - [ ] 建立 `HostedServices/MemberVerificationHostedService.cs` 定時任務服務
  - [ ] 實作新會員驗證定時任務：每 5 分鐘執行一次（`isOldCheck = false`）
  - [ ] 實作舊會員驗證定時任務：每天半夜 4 點執行（`isOldCheck = true`）
  - [ ] 實作舊會員驗證三段式分割機制：
    - 將需要檢查的 Guild 分成 3 天執行
    - 使用 `MemberCheck.dat` 檔案記錄執行進度
    - 格式：`{checkRound},{lastSkipCount}`
  - [ ] 建立驗證任務排程和執行狀態管理
  - [ ] 實作驗證錯誤處理和重試機制
  - [ ] 建立驗證統計和監控日誌

- [ ] Task 7: 實作會員驗證跨服務協調流程 (AC: 1-6)
  - [ ] 建立完整的會員驗證流程：
    1. Crawler 定時觸發會員驗證
    2. 透過 ShardRoutingService 計算目標 Shard
    3. 使用 ShardRequestService 發送 API 請求到正確 Shard
    4. Discord Shard 執行 Guild API 操作並回傳結果
    5. Crawler 處理驗證結果並更新狀態
  - [ ] 建立錯誤處理機制：
    - Shard 不可用時的降級處理
    - Guild 不在目標 Shard 上的錯誤處理
    - Discord API 權限不足的錯誤處理
  - [ ] 實作會員驗證狀態同步到資料庫

- [ ] Task 8: 建立配置管理和服務註冊 (AC: 1-6)
  - [ ] 擴展 Crawler 配置模型支援會員驗證設定
  - [ ] 建立會員驗證相關服務依賴注入配置
  - [ ] 實作健康檢查端點檢查會員驗證系統狀態
  - [ ] 建立會員驗證系統初始化和清理邏輯
  - [ ] 實作配置熱重載支援

- [ ] Task 9: 建立測試和驗證 (AC: 1-6)
  - [ ] 建立 Shard 路由計算單元測試
  - [ ] 建立 Redis PubSub 請求/回應機制整合測試
  - [ ] 建立會員驗證邏輯單元測試
  - [ ] 建立跨服務協調端到端測試
  - [ ] 建立 Discord API 代理測試（Mock Discord API）：
    - Guild 和頻道查詢操作測試
    - 角色管理操作測試（新增/移除角色）
    - 權限檢查操作測試
    - 各種訊息發送操作測試
    - 私訊發送功能測試
    - Discord API 異常處理測試（權限不足、使用者不存在等）
    - Bot 擁有者通知功能測試
  - [ ] 建立會員驗證效能測試和負載測試

## Dev Notes

### 現有會員驗證系統分析
**[Source: SharedService/YoutubeMember/YoutubeMemberService.cs + Interaction/YoutubeMember/YoutubeMember.cs]**

現有的會員驗證系統包含以下核心功能，需要完整遷移到 Crawler 服務：

**會員驗證核心邏輯**：
- `CheckMemberShip()` - 主要的定時會員驗證方法
- YouTube 會員身份檢查和角色管理
- OAuth2 token 驗證和自動續期
- Discord 用戶組新增和移除操作

**用戶互動功能**：
- `/member check` - 會員身份檢查指令
- `/member unlink` - 解除綁定指令  
- OAuth2 認證流程和 token 管理

**遷移策略**：
- 會員驗證邏輯遷移到 Crawler 服務
- 使用者互動指令保留在 Discord Shard
- 透過 shard 路由實現跨服務 Discord API 操作

### Discord Shard 路由算法
**[Source: docs/brownfield-prd.md#Discord API 約束]**

Discord 官方 shard 計算算法：
```csharp
public class ShardRoutingService
{
    private int _totalShards;
    
    public int CalculateShardId(ulong guildId)
    {
        return (int)((guildId >> 22) % (ulong)_totalShards);
    }
    
    public void UpdateTotalShards(int totalShards)
    {
        _totalShards = totalShards;
        Log.Info($"Updated total shards to: {totalShards}");
    }
}
```

**關鍵實作要求**：
- 支援動態調整 shard 數量（當 Discord 建議 shard 數量改變時）
- 確保 Guild ID 映射的正確性和一致性
- 實作 shard 健康檢查，確保目標 shard 可用

### Redis PubSub 請求/回應模式設計
**[Source: docs/brownfield-architecture.md#會員驗證流程]**

需要實作以下通訊模式：
```csharp
// 請求格式
public class ShardRequest
{
    public string RequestId { get; set; }          // 唯一請求 ID
    public string Operation { get; set; }          // API 操作類型
    public ulong GuildId { get; set; }            // Guild ID
    public Dictionary<string, object> Data { get; set; }  // 請求參數
    public DateTime Timestamp { get; set; }       // 請求時間
}

// 回應格式
public class ShardResponse
{
    public string RequestId { get; set; }          // 對應的請求 ID
    public bool Success { get; set; }             // 操作是否成功
    public object Result { get; set; }            // 回應結果
    public string ErrorMessage { get; set; }      // 錯誤訊息（如果有）
    public DateTime Timestamp { get; set; }       // 回應時間
}
```

**頻道命名規則**：
- 請求頻道：`shard-request:{shardId}`
- 回應頻道：`shard-response:{requestId}` 
- 超時設定：30 秒
- 重試策略：指數退避，最多 3 次

### OAuth2 Token 管理和加密
**[Source: Auth/TokenManager.cs + Auth/TokenCrypto.cs]**

現有的 token 管理系統使用 AES 加密和 HMAC 簽名：

```csharp
public class TokenManagerService
{
    // 遷移現有的 token 創建邏輯
    public static string CreateToken(object data, string key)
    {
        // 從現有 Auth/TokenManager.cs 遷移
        // AES 加密 + HMAC 簽名
    }
    
    // 遷移現有的 token 解密邏輯
    public static T GetTokenResponseValue<T>(string token, string key)
    {
        // 從現有 Auth/TokenManager.cs 遷移
        // 驗證簽名 + AES 解密
    }
    
    // 新增自動續期邏輯
    public async Task<bool> RefreshTokenIfNeeded(string userId)
    {
        // 檢查 token 是否即將過期
        // 自動使用 refresh_token 續期
        // 更新資料庫中的 token 記錄
    }
}
```

**加密設定**：
- AES 加密：使用前 16 位 key 作為加密金鑰
- HMAC 簽名：使用前 64 位 key 作為簽名金鑰  
- IV 生成：使用 GUID 前 16 位作為 IV
- Token 格式：`{iv}.{encrypted_data}.{signature}`

### 會員驗證定時任務實作
**[Source: SharedService/YoutubeMember/CheckMemberShip.cs]**

遷移現有會員驗證邏輯的重點，包含新舊會員驗證的區分機制：

```csharp
public class MemberVerificationService
{
    // 遷移主要驗證邏輯，保持新舊會員驗證區分
    public async Task CheckMemberShip(bool isOldCheck)
    {
        // 1. 獲取所有需要驗證的 Guild 配置
        // 2. 根據 isOldCheck 決定驗證類型和頻率
        // 3. 舊會員驗證使用三段式分割機制
        // 4. 透過 ShardRequestService 執行 Discord API 操作
        // 5. 處理驗證結果和狀態更新
    }
    
    // 舊會員驗證三段式分割機制（防止 API 用量耗盡）
    private async Task<List<GuildYoutubeMemberConfig>> HandleOldMemberCheckSplit(List<GuildYoutubeMemberConfig> needCheckList)
    {
        if (needCheckList.Count == 0) return needCheckList;
        
        try
        {
            int splitDay = 3;  // 分成 3 天執行
            int needCheckCount = needCheckList.Count / splitDay;
            int checkRound = 0, skipCount = 0, lastSkipCount = 0;

            // 從檔案讀取上次執行進度
            if (File.Exists(Utility.GetDataFilePath("MemberCheck.dat")))
            {
                string[] data = File.ReadAllText(Utility.GetDataFilePath("MemberCheck.dat")).Split(',');
                checkRound = int.Parse(data[0]);
                lastSkipCount = int.Parse(data[1]);
            }

            checkRound += 1;
            skipCount = lastSkipCount;

            // 計算本次要處理的數量
            if (checkRound >= splitDay)
            {
                needCheckCount = needCheckList.Count - lastSkipCount; // 最後一輪處理剩餘的
            }
            else
            {
                lastSkipCount += needCheckCount;
            }

            needCheckList = needCheckList.Skip(skipCount).Take(needCheckCount).ToList();

            // 重置計數器
            if (checkRound >= splitDay)
            {
                checkRound = 0;
                lastSkipCount = 0;
            }

            // 儲存進度到檔案
            File.WriteAllText(Utility.GetDataFilePath("MemberCheck.dat"), $"{checkRound},{lastSkipCount}");
        }
        catch (Exception ex)
        {
            Log.Error(ex.Demystify(), "Split member check list error");
        }
        
        return needCheckList;
    }
    
    // 批量處理優化
    public async Task ProcessGuildMemberVerification(ulong guildId, bool isOldCheck)
    {
        // 使用 shard 路由確保在正確的 Shard 上執行
        var shardId = _shardRoutingService.CalculateShardId(guildId);
        
        // 透過 PubSub 請求 Discord API 操作
        var result = await _shardRequestService.RequestShardOperation(
            guildId, 
            "CheckMemberPermissions", 
            memberVerificationData);
            
        // 處理驗證結果
        await ProcessVerificationResult(guildId, result);
    }
}
```

**驗證流程區分**：
1. **新會員驗證**（`isOldCheck = false`）：
   - 執行頻率：每 5 分鐘執行一次
   - 處理對象：`IsChecked = false` 的會員
   - 目的：快速驗證新註冊的會員
   - 會發送確認訊息和用戶組

2. **舊會員驗證**（`isOldCheck = true`）：
   - 執行頻率：每天半夜 4 點執行一次
   - 處理對象：`IsChecked = true` 的會員（重新驗證）
   - 目的：定期檢查已驗證會員是否仍有效
   - 使用三段式分割機制防止 API 用量耗盡
   - 不會重複發送確認訊息

3. **三段式分割機制**（僅限舊會員驗證）：
   - 將所有需要檢查的 Guild 分成 3 天執行
   - 使用檔案 `MemberCheck.dat` 記錄執行進度
   - 格式：`{checkRound},{lastSkipCount}`
   - 避免單日 API 調用過多導致配額耗盡

### Discord API 操作代理設計
**[Source: SharedService/YoutubeMember/CheckMemberShip.cs 中的 Discord API 調用]**

需要代理以下 Discord API 操作，根據 `CheckMemberShip.cs` 的完整需求：

```csharp
public class DiscordApiProxyService
{
    // Guild 和基礎資源查詢
    public async Task<GuildInfo> GetGuildAsync(ulong guildId)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "GetGuild",
            GuildId = guildId,
            Data = new { }
        };
        
        var result = await _shardRequestService.ExecuteRequest(request);
        return result.Success ? (GuildInfo)result.Result : null;
    }
    
    public async Task<ChannelInfo> GetTextChannelAsync(ulong guildId, ulong channelId)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "GetTextChannel",
            GuildId = guildId,
            Data = new { ChannelId = channelId }
        };
        
        var result = await _shardRequestService.ExecuteRequest(request);
        return result.Success ? (ChannelInfo)result.Result : null;
    }
    
    public async Task<RoleInfo> GetRoleAsync(ulong guildId, ulong roleId)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "GetRole",
            GuildId = guildId,
            Data = new { RoleId = roleId }
        };
        
        var result = await _shardRequestService.ExecuteRequest(request);
        return result.Success ? (RoleInfo)result.Result : null;
    }

    // 角色管理操作
    public async Task<bool> AddRoleToMemberAsync(ulong guildId, ulong userId, ulong roleId)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "AddRole",
            GuildId = guildId,
            Data = new { UserId = userId, RoleId = roleId }
        };
        
        var result = await _shardRequestService.ExecuteRequest(request);
        return result.Success;
    }
    
    public async Task<bool> RemoveRoleFromMemberAsync(ulong guildId, ulong userId, ulong roleId)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "RemoveRole",
            GuildId = guildId,
            Data = new { UserId = userId, RoleId = roleId }
        };
        
        var result = await _shardRequestService.ExecuteRequest(request);
        return result.Success;
    }

    // 權限檢查操作
    public async Task<bool> CheckBotGuildPermissionsAsync(ulong guildId)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "CheckGuildPermissions", 
            GuildId = guildId,
            Data = new { RequiredPermissions = new[] { "ManageRoles" } }
        };
        
        var result = await _shardRequestService.ExecuteRequest(request);
        return result.Success && (bool)result.Result;
    }
    
    public async Task<bool> CheckBotChannelPermissionsAsync(ulong guildId, ulong channelId)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "CheckChannelPermissions",
            GuildId = guildId,
            Data = new { 
                ChannelId = channelId,
                RequiredPermissions = new[] { "ViewChannel", "SendMessages", "EmbedLinks" }
            }
        };
        
        var result = await _shardRequestService.ExecuteRequest(request);
        return result.Success && (bool)result.Result;
    }
    
    public async Task<bool> CheckRoleValidityAsync(ulong guildId, ulong roleId)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "CheckRoleValidity",
            GuildId = guildId,
            Data = new { RoleId = roleId }
        };
        
        var result = await _shardRequestService.ExecuteRequest(request);
        return result.Success && (bool)result.Result; // false 表示是 Everyone 角色
    }

    // 訊息發送操作
    public async Task<bool> SendChannelMessageAsync(ulong guildId, ulong channelId, string message)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "SendChannelMessage",
            GuildId = guildId,
            Data = new { ChannelId = channelId, Message = message }
        };
        
        var result = await _shardRequestService.ExecuteRequest(request);
        return result.Success;
    }
    
    public async Task<bool> SendChannelErrorMessageAsync(ulong guildId, ulong channelId, ulong userId, string channelTitle, string errorMsg)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "SendChannelErrorMessage",
            GuildId = guildId,
            Data = new { 
                ChannelId = channelId, 
                UserId = userId,
                ChannelTitle = channelTitle,
                ErrorMessage = errorMsg
            }
        };
        
        var result = await _shardRequestService.ExecuteRequest(request);
        return result.Success;
    }
    
    public async Task<bool> SendChannelConfirmMessageAsync(ulong guildId, ulong channelId, string title, string description)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "SendChannelConfirmMessage",
            GuildId = guildId,
            Data = new { 
                ChannelId = channelId,
                Title = title,
                Description = description
            }
        };
        
        var result = await _shardRequestService.ExecuteRequest(request);
        return result.Success;
    }
    
    public async Task<bool> SendChannelEmbedMessageAsync(ulong guildId, ulong channelId, Dictionary<string, object> embedData)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "SendChannelEmbedMessage",
            GuildId = guildId,
            Data = new { 
                ChannelId = channelId,
                EmbedData = embedData
            }
        };
        
        var result = await _shardRequestService.ExecuteRequest(request);
        return result.Success;
    }

    // 私訊操作
    public async Task<bool> SendUserErrorMessageAsync(ulong userId, string message, ulong? logChannelId = null)
    {
        // 需要通過任一可用的 Shard 發送私訊（私訊不受 Guild 限制）
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "SendUserErrorMessage",
            GuildId = 0, // 私訊不需要 Guild
            Data = new { 
                UserId = userId,
                Message = message,
                LogChannelId = logChannelId
            }
        };
        
        var result = await _shardRequestService.ExecuteRequestToAnyAvailableShard(request);
        return result.Success;
    }
    
    public async Task<bool> SendUserConfirmMessageAsync(ulong userId, string message, ulong? logChannelId = null)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "SendUserConfirmMessage",
            GuildId = 0,
            Data = new { 
                UserId = userId,
                Message = message,
                LogChannelId = logChannelId
            }
        };
        
        var result = await _shardRequestService.ExecuteRequestToAnyAvailableShard(request);
        return result.Success;
    }
    
    public async Task<bool> SendOwnerErrorMessageAsync(string message, ulong? logChannelId = null)
    {
        var request = new ShardRequest
        {
            RequestId = Guid.NewGuid().ToString(),
            Operation = "SendOwnerErrorMessage",
            GuildId = 0,
            Data = new { 
                Message = message,
                LogChannelId = logChannelId
            }
        };
        
        var result = await _shardRequestService.ExecuteRequestToAnyAvailableShard(request);
        return result.Success;
    }
}

// 支援的資料模型
public class GuildInfo
{
    public ulong Id { get; set; }
    public string Name { get; set; }
    public bool Exists { get; set; }
}

public class ChannelInfo 
{
    public ulong Id { get; set; }
    public string Name { get; set; }
    public bool Exists { get; set; }
}

public class RoleInfo
{
    public ulong Id { get; set; }
    public string Name { get; set; }
    public bool IsEveryone { get; set; }
    public bool Exists { get; set; }
}
```

**Discord API 操作分類**：

1. **Guild 和資源查詢**：
   - `_client.GetGuild()` → `GetGuildAsync()`
   - `guild.GetTextChannel()` → `GetTextChannelAsync()`
   - `guild.GetRole()` → `GetRoleAsync()`

2. **權限檢查**：
   - `guild.CurrentUser.GuildPermissions.ManageRoles` → `CheckBotGuildPermissionsAsync()`
   - `guild.CurrentUser.GetPermissions(channel)` → `CheckBotChannelPermissionsAsync()`
   - `role == guild.EveryoneRole` → `CheckRoleValidityAsync()`

3. **角色管理**：
   - `_client.Rest.AddRoleAsync()` → `AddRoleToMemberAsync()`
   - `_client.Rest.RemoveRoleAsync()` → `RemoveRoleFromMemberAsync()`

4. **訊息發送**：
   - `logChannel.SendMessageAsync()` → `SendChannelMessageAsync()`
   - `logChannel.SendErrorMessageAsync()` → `SendChannelErrorMessageAsync()`
   - `logChannel.SendConfirmMessageAsync()` → `SendChannelConfirmMessageAsync()`
   - `userId.SendErrorMessageAsync()` → `SendUserErrorMessageAsync()`
   - `userId.SendConfirmMessageAsync()` → `SendUserConfirmMessageAsync()`
   - `Bot.ApplicatonOwner.Id.SendErrorMessageAsync()` → `SendOwnerErrorMessageAsync()`

5. **錯誤處理**：
   - Discord.Net.HttpException 處理
   - DiscordErrorCode 分類處理
   - 權限不足、使用者不存在、Guild 不存在等情況

### 錯誤處理和降級機制
**[Source: docs/brownfield-prd.md#風險評估]**

實作完整的錯誤處理機制：

```csharp
public class MemberVerificationErrorHandler
{
    public async Task<bool> HandleShardRequestError(ShardRequest request, Exception ex)
    {
        switch (ex)
        {
            case TimeoutException:
                // Shard 回應超時，重試機制
                return await RetryWithBackoff(request);
                
            case ShardNotAvailableException:
                // 目標 Shard 不可用，記錄並稍後重試
                Log.Warn($"Shard {request.GuildId} not available, scheduling retry");
                await _retryQueue.ScheduleRetry(request, TimeSpan.FromMinutes(5));
                return false;
                
            case InsufficientPermissionsException:
                // Bot 權限不足，通知 Guild 管理員
                await NotifyGuildAdmin(request.GuildId, "Bot 需要管理身分組權限");
                return false;
                
            case GuildNotFoundOnShardException:
                // Guild 不在預期的 Shard 上，更新路由
                await UpdateShardRouting(request.GuildId);
                return await RetryWithUpdatedRouting(request);
                
            default:
                Log.Error(ex, $"Unknown error in member verification: {request.RequestId}");
                return false;
        }
    }
}
```

### 會員驗證狀態管理
**[Source: DataBase/Table/ 中的會員驗證相關資料表]**

保持現有資料庫結構不變，繼續使用：
- `YoutubeMemberCheck` - 會員檢查記錄
- `GuildYoutubeMemberConfig` - Guild 會員驗證配置
- `UserYoutubeOAuth` - 使用者 OAuth token 記錄

```csharp
public class MemberVerificationStateManager  
{
    // 更新會員驗證狀態
    public async Task UpdateMemberVerificationStatus(ulong userId, ulong guildId, bool isValid)
    {
        using var db = _dbService.GetDbContext();
        
        var memberCheck = await db.YoutubeMemberCheck
            .FirstOrDefaultAsync(x => x.UserId == userId && x.GuildId == guildId);
            
        if (memberCheck != null)
        {
            memberCheck.IsValid = isValid;
            memberCheck.LastCheckedAt = DateTime.UtcNow;
        }
        
        await db.SaveChangesAsync();
    }
    
    // 快取驗證結果
    private readonly MemoryCache _verificationCache = new MemoryCache();
    
    public async Task<bool?> GetCachedVerificationResult(ulong userId, string youtubeChannelId)
    {
        var cacheKey = $"{userId}_{youtubeChannelId}";
        return _verificationCache.Get<bool?>(cacheKey);
    }
    
    public async Task SetCachedVerificationResult(ulong userId, string youtubeChannelId, bool isValid)
    {
        var cacheKey = $"{userId}_{youtubeChannelId}";
        var cacheOptions = new MemoryCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(360),
            Priority = CacheItemPriority.Normal
        };
        _verificationCache.Set(cacheKey, isValid, cacheOptions);
    }
}
```

### 服務註冊和配置
**[Source: Program.cs + BotConfig.cs]**

在 Crawler 服務中註冊會員驗證相關服務：

```csharp
// Program.cs 中的服務註冊
services.AddSingleton<ShardRoutingService>();
services.AddSingleton<ShardRequestService>();
services.AddScoped<MemberVerificationService>();
services.AddScoped<TokenManagerService>();
services.AddScoped<DiscordApiProxyService>();
services.AddSingleton<MemberVerificationErrorHandler>();
services.AddHostedService<MemberVerificationHostedService>();

// 配置擴展
public class CrawlerConfig
{
    public MemberVerificationConfig MemberVerification { get; set; } = new();
}

public class MemberVerificationConfig
{
    public int VerificationIntervalMinutes { get; set; } = 30;
    public int ShardRequestTimeoutSeconds { get; set; } = 30;
    public int MaxRetryAttempts { get; set; } = 3;
    public bool EnableVerificationCache { get; set; } = true;
    public int CacheExpirationMinutes { get; set; } = 360;
}
```

### Redis 事件整合
**[Source: Interaction/YoutubeMember/YoutubeMember.cs 中的 Redis 事件]**

需要監聽的現有 Redis 事件：
- `member.revokeToken` - 使用者撤銷授權事件

```csharp
public class MemberVerificationRedisHandler
{
    public async Task Initialize()
    {
        await _redis.SubscribeAsync(new RedisChannel("member.revokeToken", RedisChannel.PatternMode.Literal), 
            async (channel, message) => 
            {
                var userId = Convert.ToUInt64(message);
                await HandleTokenRevocation(userId);
            });
    }
    
    private async Task HandleTokenRevocation(ulong userId)
    {
        Log.Info($"Handling token revocation for user: {userId}");
        
        // 從資料庫移除 OAuth token
        using var db = _dbService.GetDbContext();
        var oauthRecord = await db.UserYoutubeOAuth
            .FirstOrDefaultAsync(x => x.UserId == userId);
            
        if (oauthRecord != null)
        {
            db.UserYoutubeOAuth.Remove(oauthRecord);
            await db.SaveChangesAsync();
        }
        
        // 清除快取
        _verificationCache.Remove($"{userId}_*");
    }
}
```

### Testing

**單元測試要求**:
- Shard 路由計算邏輯測試
- Token 加密/解密功能測試
- 會員驗證邏輯測試（Mock Discord API）
- Redis PubSub 請求/回應機制測試
- 錯誤處理和重試機制測試

**整合測試要求**:
- 跨服務會員驗證流程測試
- Discord API 代理功能測試
- 定時任務執行測試
- 資料庫操作整合測試

**效能測試要求**:
- 大量 Guild 會員驗證效能測試
- Redis PubSub 通訊效能測試
- 並行請求處理能力測試
- 記憶體使用和快取效率測試

**手動測試驗證**:
1. 驗證 shard 路由計算正確性（使用不同 Guild ID）
2. 測試會員驗證定時任務執行（新會員 5 分鐘、舊會員半夜 4 點）
3. 驗證 Discord API 代理功能：
   - Guild/頻道/角色查詢功能
   - 角色新增/移除操作
   - Bot 權限檢查（Guild 和頻道權限）
   - 各種訊息發送功能（普通、錯誤、確認、Embed）
   - 私訊發送功能
   - Bot 擁有者錯誤通知功能
4. 測試 token 續期和撤銷流程
5. 驗證錯誤處理機制：
   - Shard 不可用時的處理
   - Guild 不存在的處理
   - 頻道/角色不存在的處理
   - Bot 權限不足的處理
   - 使用者已離開伺服器的處理
   - 角色為 Everyone 的檢查
6. 測試會員驗證結果快取和狀態同步
7. 驗證舊會員驗證的三段式分割機制
8. 驗證跨服務通訊的穩定性和正確性
9. 測試所有 YouTube 會員驗證錯誤情況的處理

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | Story 初始建立 | Scrum Master |

## Dev Agent Record

_此區段由開發代理在實作期間填寫_

### Agent Model Used

_待開發代理填寫_

### Debug Log References

_待開發代理填寫_

### Completion Notes List

_待開發代理填寫_

### File List

_待開發代理填寫_

## QA Results

_此區段由 QA 代理在完成故事實作的 QA 審查後填寫_

````
