# Story 1.4: 追蹤管理指令 PubSub 整合

## Status
Draft

## Story
**As a** 系統架構師,
**I want** 修改追蹤新增/移除指令透過 Redis PubSub 通知未來的 Crawler 服務,
**so that** 建立服務間的即時通訊機制，支援動態追蹤管理

## Acceptance Criteria

1. [ ] 修改 YouTube 追蹤指令發送 `stream.follow`/`stream.unfollow` 事件
   - `/youtube follow` 指令發送 follow 事件
   - `/youtube unfollow` 指令發送 unfollow 事件
   - 包含完整的追蹤目標資訊（頻道 ID、Guild ID、Channel ID）
2. [ ] 修改 Twitch 追蹤指令整合 PubSub 通知
   - Twitch 使用者追蹤/取消追蹤事件
   - 支援 Twitch 頻道 ID 和使用者名稱解析
3. [ ] 修改 Twitter 追蹤指令整合 PubSub 通知  
   - Twitter Spaces 追蹤事件
   - 處理 Twitter 使用者 ID 和 handle 對應
4. [ ] 修改 TwitCasting 追蹤指令整合 PubSub 通知
   - TwitCasting 使用者追蹤事件
   - 支援使用者 ID 和螢幕名稱
5. [ ] 實作追蹤資料序列化和事件格式標準化
   - 定義統一的事件資料格式
   - JSON 序列化追蹤目標資訊
   - 包含必要的元數據（時間戳記、操作者）
6. [ ] 保持資料庫操作邏輯不變
   - 指令執行時仍然寫入資料庫
   - PubSub 事件為額外的通知機制
   - 確保資料一致性

## Tasks / Subtasks

- [ ] Task 1: 定義統一事件資料模型 (AC: 5)
  - [ ] 建立 `Models/PubSubEvents.cs` 定義事件結構
  - [ ] 設計 `StreamFollowEvent` 資料模型：
    - 平台識別 (youtube, twitch, twitter, twitcasting)
    - 追蹤目標識別 (頻道ID、使用者名稱等)
    - Guild 和 Channel 資訊
    - 操作者資訊和時間戳記
  - [ ] 設計 `StreamUnfollowEvent` 資料模型
  - [ ] 實作 JSON 序列化屬性和驗證

- [ ] Task 2: 建立 PubSub 事件發送服務 (AC: 5, 6)
  - [ ] 建立 `Services/PubSubEventService.cs` 統一事件發送
  - [ ] 實作事件發送方法：
    - `PublishFollowEventAsync(StreamFollowEvent event)`
    - `PublishUnfollowEventAsync(StreamUnfollowEvent event)`
  - [ ] 實作 JSON 序列化和 Redis 發送邏輯
  - [ ] 實作事件發送失敗的錯誤處理
  - [ ] 在依賴注入中註冊 PubSubEventService

- [ ] Task 3: 重構 YouTube 追蹤指令 (AC: 1, 6)
  - [ ] 修改 `Command/Youtube/` 的 Follow/Unfollow 指令：
    - 保持現有資料庫寫入邏輯
    - 新增 PubSub 事件發送
    - 確保資料庫操作成功後才發送事件
  - [ ] 修改 `Interaction/Youtube/` 的斜線指令：
    - `/youtube follow` 指令整合
    - `/youtube unfollow` 指令整合
    - 保持現有 Embed 回應格式（Story 1.3）
  - [ ] 實作 YouTube 特定的事件資料：
    - 頻道 ID 和頻道標題
    - 追蹤類型 (直播、影片、會員內容)

- [ ] Task 4: 重構 Twitch 追蹤指令 (AC: 2, 6)
  - [ ] 修改 `Command/Twitch/` 和 `Interaction/Twitch/` 指令：
    - Twitch 使用者名稱解析邏輯保持不變
    - 新增 follow/unfollow 事件發送
    - 包含 Twitch User ID 和 Display Name
  - [ ] 處理 Twitch API 的用戶名稱/ID 轉換
  - [ ] 確保 Twitch EventSub 相容性資料

- [ ] Task 5: 重構 Twitter 和 TwitCasting 指令 (AC: 3, 4, 6)
  - [ ] 修改 Twitter 追蹤指令：
    - Twitter Spaces 追蹤事件發送
    - 處理 Twitter Handle 和 User ID 對應
    - 支援 Twitter 不穩定 API 的錯誤處理
  - [ ] 修改 TwitCasting 追蹤指令：
    - TwitCasting 使用者追蹤事件
    - 使用者 ID 和螢幕名稱處理
    - 支援 TwitCasting API 特性

- [ ] Task 6: 實作事件發送錯誤處理 (AC: 5, 6)
  - [ ] Redis 連接失敗處理：
    - 記錄錯誤但不影響指令執行
    - 資料庫操作優先，PubSub 為輔助
    - 實作重試機制（最多3次）
  - [ ] 事件序列化錯誤處理：
    - 記錄詳細錯誤資訊
    - 避免因事件發送失敗導致指令異常
  - [ ] 實作降級策略（PubSub 不可用時的處理）

- [ ] Task 7: 資料一致性確保 (AC: 6)
  - [ ] 實作事務性處理：
    - 資料庫操作成功後才發送 PubSub 事件
    - 避免資料庫和 PubSub 狀態不一致
  - [ ] 實作補償機制：
    - 定期檢查資料庫和 PubSub 狀態一致性
    - 支援手動重新同步（管理員指令）
  - [ ] 建立資料一致性監控和告警

- [ ] Task 8: 整合測試和驗證 (AC: 1-6)
  - [ ] 測試所有平台追蹤指令：
    - 驗證資料庫寫入正常
    - 驗證 PubSub 事件正確發送
    - 驗證事件資料格式正確
  - [ ] 測試錯誤情況處理：
    - Redis 連接失敗
    - 事件序列化錯誤
    - 資料庫操作失敗
  - [ ] 驗證與現有功能的相容性

## Dev Notes

### 服務間通訊架構準備
**[Source: docs/brownfield-prd.md#FR5-動態追蹤管理]**

此 Story 是建立 Discord Shard 與未來 Crawler 服務之間即時通訊的關鍵步驟。當使用者執行追蹤管理指令時，系統需要即時通知 Crawler 服務調整監控目標，實現動態追蹤管理。

### PubSub 通訊協定設計
**[Source: docs/brownfield-architecture.md#Redis-PubSub-頻道]**

**事件頻道規範**:
- `stream.follow`: Discord Shard → Crawler 新增追蹤請求
- `stream.unfollow`: Discord Shard → Crawler 移除追蹤請求

這些事件將在未來被 Crawler 服務監聽，用於動態調整追蹤目標清單。

### 統一事件資料模型

**StreamFollowEvent 結構**:
```csharp
public class StreamFollowEvent
{
    [JsonProperty("platform")]
    public string Platform { get; set; } // youtube, twitch, twitter, twitcasting
    
    [JsonProperty("stream_key")]
    public string StreamKey { get; set; } // 平台特定的識別符
    
    [JsonProperty("guild_id")]
    public ulong GuildId { get; set; }
    
    [JsonProperty("channel_id")]
    public ulong ChannelId { get; set; } // Discord 通知頻道
    
    [JsonProperty("user_id")]
    public ulong UserId { get; set; } // 操作者
    
    [JsonProperty("timestamp")]
    public DateTime Timestamp { get; set; }
    
    [JsonProperty("metadata")]
    public Dictionary<string, object> Metadata { get; set; }
    
    // 平台特定資料
    [JsonProperty("platform_data")]
    public object PlatformData { get; set; }
}

public class StreamUnfollowEvent
{
    [JsonProperty("platform")]
    public string Platform { get; set; }
    
    [JsonProperty("stream_key")]
    public string StreamKey { get; set; }
    
    [JsonProperty("guild_id")]
    public ulong GuildId { get; set; }
    
    [JsonProperty("user_id")]
    public ulong UserId { get; set; }
    
    [JsonProperty("timestamp")]
    public DateTime Timestamp { get; set; }
}
```

**平台特定 StreamKey 格式**:
```csharp
public static class StreamKeyFormats
{
    // YouTube: channel_id 或 video_id
    public static string YouTube(string channelId) => $"yt_channel:{channelId}";
    public static string YouTubeVideo(string videoId) => $"yt_video:{videoId}";
    
    // Twitch: user_login 或 user_id
    public static string Twitch(string userLogin) => $"twitch_user:{userLogin}";
    public static string TwitchById(string userId) => $"twitch_id:{userId}";
    
    // Twitter: user_id 或 screen_name
    public static string Twitter(string userId) => $"twitter_user:{userId}";
    
    // TwitCasting: user_id
    public static string TwitCasting(string userId) => $"twitcasting_user:{userId}";
}
```

### PubSub 事件服務設計

**PubSubEventService 架構**:
```csharp
public interface IPubSubEventService
{
    Task PublishFollowEventAsync(StreamFollowEvent followEvent);
    Task PublishUnfollowEventAsync(StreamUnfollowEvent unfollowEvent);
    Task<bool> IsConnectedAsync();
}

public class PubSubEventService : IPubSubEventService
{
    private readonly RedisConnection _redisConnection;
    private readonly ILogger<PubSubEventService> _logger;
    
    public async Task PublishFollowEventAsync(StreamFollowEvent followEvent)
    {
        try
        {
            var json = JsonConvert.SerializeObject(followEvent);
            await _redisConnection.Redis.PublishAsync("stream.follow", json);
            
            _logger.LogInformation("Published follow event: {Platform} {StreamKey} for Guild {GuildId}", 
                followEvent.Platform, followEvent.StreamKey, followEvent.GuildId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to publish follow event");
            // 不拋出異常，避免影響主要業務邏輯
        }
    }
}
```

### 指令重構範例

**YouTube Follow 指令重構**:
```csharp
// 重構前
[SlashCommand("follow", "追蹤 YouTube 頻道")]
public async Task FollowYouTubeChannel(string channelUrl)
{
    // 解析和驗證 URL
    var channelId = ExtractChannelId(channelUrl);
    
    // 寫入資料庫
    var followedStream = new FollowedStream
    {
        Platform = "youtube",
        ChannelId = channelId,
        GuildId = Context.Guild.Id,
        // ... 其他屬性
    };
    
    await _dbService.AddFollowedStreamAsync(followedStream);
    
    var embed = EmbedStyles.CreateSuccess("追蹤成功", $"已追蹤頻道 {channelTitle}").Build();
    await RespondAsync(embed: embed);
}

// 重構後
[SlashCommand("follow", "追蹤 YouTube 頻道")]
public async Task FollowYouTubeChannel(string channelUrl)
{
    try
    {
        // 解析和驗證 URL
        var channelId = ExtractChannelId(channelUrl);
        var channelInfo = await _youtubeService.GetChannelInfoAsync(channelId);
        
        // 寫入資料庫 (保持現有邏輯)
        var followedStream = new FollowedStream
        {
            Platform = "youtube",
            ChannelId = channelId,
            ChannelTitle = channelInfo.Title,
            GuildId = Context.Guild.Id,
            ChannelId = Context.Channel.Id,
            UserId = Context.User.Id,
            CreatedAt = DateTime.Now
        };
        
        var dbResult = await _dbService.AddFollowedStreamAsync(followedStream);
        
        // 發送 PubSub 事件 (新增邏輯)
        var followEvent = new StreamFollowEvent
        {
            Platform = "youtube",
            StreamKey = StreamKeyFormats.YouTube(channelId),
            GuildId = Context.Guild.Id,
            ChannelId = Context.Channel.Id,
            UserId = Context.User.Id,
            Timestamp = DateTime.UtcNow,
            Metadata = new Dictionary<string, object>
            {
                ["channel_title"] = channelInfo.Title,
                ["channel_url"] = channelUrl
            }
        };
        
        // 資料庫操作成功後才發送事件
        await _pubSubEventService.PublishFollowEventAsync(followEvent);
        
        var embed = EmbedStyles.CreateSuccess("追蹤成功", 
            $"已成功追蹤 [{channelInfo.Title}]({channelUrl})")
            .WithThumbnailUrl(channelInfo.ThumbnailUrl)
            .AddField("頻道 ID", channelId, true)
            .Build();
            
        await RespondAsync(embed: embed);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to follow YouTube channel: {ChannelUrl}", channelUrl);
        
        var errorEmbed = EmbedStyles.CreateError("追蹤失敗", ex.Message,
            "請檢查頻道 URL 是否正確，或稍後再試").Build();
            
        await RespondAsync(embed: errorEmbed);
    }
}
```

### 平台特定處理邏輯

**Twitch 使用者名稱解析**:
```csharp
private async Task<StreamFollowEvent> CreateTwitchFollowEvent(string userInput, SocketSlashCommand context)
{
    // Twitch API 調用解析使用者名稱到 User ID
    var twitchUser = await _twitchService.GetUserByLoginAsync(userInput);
    
    return new StreamFollowEvent
    {
        Platform = "twitch",
        StreamKey = StreamKeyFormats.Twitch(twitchUser.Login),
        GuildId = context.Guild.Id,
        ChannelId = context.Channel.Id,
        UserId = context.User.Id,
        Timestamp = DateTime.UtcNow,
        PlatformData = new
        {
            user_id = twitchUser.Id,
            login = twitchUser.Login,
            display_name = twitchUser.DisplayName
        }
    };
}
```

**Twitter API 不穩定性處理**:
```csharp
private async Task<StreamFollowEvent> CreateTwitterFollowEvent(string userInput, SocketSlashCommand context)
{
    try
    {
        // Twitter API 可能不穩定，實作重試邏輯
        var twitterUser = await _twitterService.GetUserInfoAsync(userInput);
        
        return new StreamFollowEvent
        {
            Platform = "twitter",
            StreamKey = StreamKeyFormats.Twitter(twitterUser.Id),
            GuildId = context.Guild.Id,
            ChannelId = context.Channel.Id,
            UserId = context.User.Id,
            Timestamp = DateTime.UtcNow,
            PlatformData = new
            {
                user_id = twitterUser.Id,
                screen_name = twitterUser.ScreenName,
                display_name = twitterUser.Name
            }
        };
    }
    catch (TwitterApiException ex) when (ex.StatusCode == HttpStatusCode.TooManyRequests)
    {
        // 處理 Rate Limit
        throw new InvalidOperationException("Twitter API 暫時不可用，請稍後再試");
    }
}
```

### 資料一致性策略

**事務性處理模式**:
```csharp
public async Task<bool> AddFollowWithEventAsync(FollowedStream followedStream, StreamFollowEvent followEvent)
{
    using var transaction = await _dbService.BeginTransactionAsync();
    
    try
    {
        // 1. 資料庫操作
        await _dbService.AddFollowedStreamAsync(followedStream);
        await transaction.CommitAsync();
        
        // 2. 資料庫提交成功後發送 PubSub 事件
        await _pubSubEventService.PublishFollowEventAsync(followEvent);
        
        return true;
    }
    catch (Exception)
    {
        await transaction.RollbackAsync();
        throw; // 讓調用方處理錯誤
    }
}
```

**降級策略**:
```csharp
public async Task PublishFollowEventAsync(StreamFollowEvent followEvent)
{
    try
    {
        if (!await IsRedisAvailableAsync())
        {
            _logger.LogWarning("Redis unavailable, storing event for later retry");
            await StoreEventForRetryAsync(followEvent);
            return;
        }
        
        var json = JsonConvert.SerializeObject(followEvent);
        await _redisConnection.Redis.PublishAsync("stream.follow", json);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Failed to publish follow event, storing for retry");
        await StoreEventForRetryAsync(followEvent);
    }
}
```

### 錯誤處理和監控

**常見錯誤場景**:
- Redis 連接失敗：不影響主要功能，記錄錯誤並稍後重試
- 事件序列化錯誤：記錄詳細錯誤信息，檢查資料模型
- 平台 API 調用失敗：向使用者顯示友善錯誤信息

**監控指標**:
- PubSub 事件發送成功率
- 事件發送延遲
- Redis 連接狀態
- 資料庫與 PubSub 一致性檢查

### Testing

**單元測試覆蓋**:
- 事件資料模型序列化/反序列化
- PubSub 事件發送邏輯
- 錯誤處理和降級策略
- 平台特定資料轉換

**整合測試場景**:
- 完整的追蹤指令執行流程
- Redis 連接中斷時的處理
- 資料庫操作與 PubSub 事件一致性
- 各平台追蹤指令的端到端測試

**手動測試驗證**:
1. 執行各平台的追蹤指令
2. 驗證資料庫中的資料正確性
3. 使用 Redis CLI 監控事件發送
4. 測試 Redis 斷線恢復場景

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | Story 初始建立 | Scrum Master |

## Dev Agent Record

_此區段由開發代理在實作期間填寫_

### Agent Model Used

_待開發代理填寫_

### Debug Log References

_待開發代理填寫_

### Completion Notes List

_待開發代理填寫_

### File List

_待開發代理填寫_

## QA Results

_此區段由 QA 代理在完成故事實作的 QA 審查後填寫_
