# Story 3.1: Coordinator gRPC 服務建立

## Status
Draft

## Story
**As a** 系統管理員,
**I want** 一個 Coordinator 服務能透過 gRPC 統一管理所有服務（Crawler 和 Discord Shard）,
**so that** 我可以透過標準化的 API 監控服務狀態、重啟故障服務並確保整個系統協調運行

## Acceptance Criteria

1. 建立 `StreamNotifyBot.Coordinator/` 專案，使用 ASP.NET Core gRPC 框架
2. 定義完整的 `coordinator.proto` gRPC 服務規範，包含心跳、狀態查詢、重啟指令等方法
3. 實作 `CoordinatorService.cs` gRPC 服務端，處理所有 RPC 方法調用
4. 實作服務註冊和狀態追蹤機制，維護所有被管理服務的運行狀態
5. 支援併發安全的服務狀態管理，避免競爭條件
6. 建立服務心跳超時檢測和狀態狀態機轉換邏輯

## Tasks / Subtasks

- [ ] 建立 ASP.NET Core gRPC 專案架構 (AC: 1)
  - [ ] 建立 `StreamNotifyBot.Coordinator/` 專案目錄
  - [ ] 配置 `StreamNotifyBot.Coordinator.csproj` 含 Grpc.AspNetCore 套件
  - [ ] 建立基礎專案結構目錄（Services/, Models/, Configuration/）
  
- [ ] 定義 gRPC 服務協定 (AC: 2)
  - [ ] 建立 `Protos/coordinator.proto` 檔案
  - [ ] 定義 Coordinator service 介面和所有 RPC 方法
  - [ ] 定義 HeartbeatRequest/Reply, GetStatusRequest/Reply 等訊息格式
  - [ ] 定義 RestartService, GetAllStatuses RPC 方法
  
- [ ] 實作 CoordinatorService gRPC 服務端 (AC: 3)
  - [ ] 建立 `Services/CoordinatorService.cs` 繼承生成的 gRPC 基類
  - [ ] 實作 Heartbeat() RPC 方法處理服務心跳
  - [ ] 實作 GetStatus() RPC 方法查詢單一服務狀態
  - [ ] 實作 GetAllStatuses() RPC 方法查詢所有服務狀態
  - [ ] 實作 RestartService() RPC 方法觸發服務重啟
  
- [ ] 建立服務狀態管理系統 (AC: 4, 5)
  - [ ] 建立 `Models/ServiceInfo.cs` 服務資訊模型
  - [ ] 建立 `Services/ServiceStateManager.cs` 狀態管理器
  - [ ] 實作併發安全的服務註冊和狀態更新機制
  - [ ] 建立服務實例字典，支援 Crawler 和多個 Discord Shard
  
- [ ] 實作心跳監控和超時檢測 (AC: 6)
  - [ ] 建立服務狀態狀態機（Registering, Healthy, Unresponsive, Failed）
  - [ ] 實作心跳超時檢測背景任務
  - [ ] 建立狀態轉換邏輯和事件通知機制
  - [ ] 實作服務失聯時的自動狀態更新

## Dev Notes

### Previous Story Insights
無 - 這是 Epic 3 的第一個 Story

### gRPC 服務規範設計
基於 NadekoBot Coordinator 實作模式，建立標準化服務管理 API：

**核心 gRPC 服務定義：**
```protobuf
syntax = "proto3";
package coordinator;

service Coordinator {
  // 接收服務心跳，回傳是否需要優雅關閉
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatReply);
  
  // 查詢單一服務狀態
  rpc GetStatus(GetStatusRequest) returns (GetStatusReply);
  
  // 查詢所有服務狀態
  rpc GetAllStatuses(GetAllStatusesRequest) returns (GetAllStatusesReply);
  
  // 重啟指定服務
  rpc RestartService(RestartServiceRequest) returns (RestartServiceReply);
}

message HeartbeatRequest {
  string service_id = 1;          // 服務唯一識別符
  int32 shard_id = 2;            // Discord Shard 編號（Crawler 為 -1）
  int32 guild_count = 3;         // Guild 數量（Discord Shard 才有）
  string connection_state = 4;    // Discord 連接狀態
  int64 uptime_seconds = 5;      // 服務運行秒數
}

message HeartbeatReply {
  bool graceful_imminent = 1;     // 是否要求優雅關閉
}
```

[Source: docs/brownfield-architecture.md#API 規格說明]

**服務狀態模型：**
```csharp
public enum ServiceStatus
{
    Registering,    // 服務註冊中，尚未接收到第一次心跳
    Healthy,        // 正常運行，心跳正常
    Unresponsive,   // 心跳超時，但尚未確定故障
    Failed,         // 確定故障，需要重啟
    Restarting      // 重啟中
}

public class ServiceInfo
{
    public string ServiceId { get; set; }
    public int ShardId { get; set; }
    public ServiceStatus Status { get; set; }
    public DateTime LastHeartbeat { get; set; }
    public int GuildCount { get; set; }
    public string ConnectionState { get; set; }
    public TimeSpan Uptime { get; set; }
}
```

[Source: docs/brownfield-architecture.md#Coordinator 架構設計]

### 服務管理架構
**Coordinator 核心職責：**
- 統一管理 1 個 Crawler 服務 + N 個 Discord Shard 進程
- 接收所有服務的 gRPC 心跳回報
- 監控服務健康狀態並觸發自動重啟
- 提供統一的服務狀態查詢和管理 API

**服務識別機制：**
- Crawler 服務：`service_id = "crawler"`, `shard_id = -1`
- Discord Shard：`service_id = "discord-shard"`, `shard_id = 0..N`

[Source: docs/brownfield-architecture.md#Coordinator 職責增強]

### 併發安全考量
使用 `ConcurrentDictionary` 管理服務狀態，確保多線程安全：

```csharp
private readonly ConcurrentDictionary<string, ServiceInfo> _services = new();
private readonly object _statusLock = new object();

public void UpdateServiceStatus(string serviceId, ServiceStatus newStatus)
{
    lock (_statusLock)
    {
        if (_services.TryGetValue(serviceId, out var service))
        {
            var oldStatus = service.Status;
            service.Status = newStatus;
            service.LastUpdate = DateTime.UtcNow;
            
            // 記錄狀態變化
            _logger.LogInformation("Service {ServiceId} status: {OldStatus} -> {NewStatus}", 
                serviceId, oldStatus, newStatus);
        }
    }
}
```

[Source: docs/brownfield-prd.md#NFR2 系統可用性]

### ASP.NET Core 整合配置
**gRPC 服務註冊：**
```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddGrpc();

// 註冊 Coordinator 相關服務
builder.Services.AddSingleton<ServiceStateManager>();
builder.Services.AddHostedService<HeartbeatMonitorService>();

var app = builder.Build();
app.MapGrpcService<CoordinatorService>();
app.Run();
```

**設定檔格式（使用標準 appsettings.json）：**
```json
{
  "Grpc": {
    "Endpoints": {
      "Http2": {
        "Url": "http://localhost:6110"
      }
    }
  },
  "Monitoring": {
    "HeartbeatTimeoutSeconds": 30,
    "RecheckIntervalMs": 2000
  }
}
```

[Source: docs/brownfield-architecture.md#技術堆疊]

### Project Structure
專案檔案將建立在現有 solution 中作為新專案：
```
DiscordStreamNotifyBot.sln
├── DiscordStreamNotifyBot/           # 現有 Discord Bot 專案
├── StreamNotifyBot.Crawler/          # Epic 2 建立的 Crawler 專案
└── StreamNotifyBot.Coordinator/      # 本 Story 建立的專案
    ├── StreamNotifyBot.Coordinator.csproj
    ├── Program.cs
    ├── Protos/
    │   └── coordinator.proto
    ├── Services/
    │   ├── CoordinatorService.cs
    │   └── ServiceStateManager.cs
    ├── Models/
    │   └── ServiceInfo.cs
    └── Configuration/
```

[Source: docs/brownfield-architecture.md#實際技術堆疊]

### Testing

**單元測試需求：**
- gRPC 方法調用測試
- 併發安全的狀態管理測試  
- 心跳超時檢測邏輯測試
- 服務狀態狀態機轉換測試

**測試框架和工具：**
- xUnit 作為測試框架
- Grpc.Net.Client.Web 用於 gRPC 客戶端測試
- TestServer 用於整合測試

[Source: docs/epic-stories.md#測試策略]

### 技術約束
- 使用 .NET 8.0 和 ASP.NET Core
- gRPC HTTP/2 協定，預設端口 6110
- 支援跨平台部署（Windows/Linux）
- 整合現有日誌框架（Console 輸出）

[Source: docs/brownfield-prd.md#平台 API 限制]

### 安全考量
- gRPC 服務使用 HTTP（開發環境）或 HTTPS（生產環境）
- 服務間通訊限制在內部網路
- 無外部暴露端點，僅供 Crawler 和 Discord Shard 連接

[Source: docs/brownfield-prd.md#技術約束和限制]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | 建立 Coordinator gRPC 服務故事 | Scrum Master |
