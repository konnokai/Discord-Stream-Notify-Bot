# Story 3.3: YAML 配置管理系統

## Status
Draft

## Story
**As a** 系統管理員,
**I want** Coordinator 服務支援 YAML 格式的統一配置管理，包含環境變數替換和熱重載功能,
**so that** 我可以用結構化且易讀的方式管理所有服務配置，並能在運行時動態調整設定而無需重啟服務

## Acceptance Criteria

1. 建立 `coord.yml` 配置檔案格式定義，支援服務定義、監控參數和全域設定
2. 實作 YAML 配置解析和驗證機制，確保配置檔案格式正確且包含必要參數
3. 建立環境變數替換機制，支援 `{{variable}}` 語法動態替換敏感資訊
4. 支援服務配置熱重載，監控配置檔案變更並自動套用新設定

## Tasks / Subtasks

- [ ] 建立 YAML 配置檔案結構定義 (AC: 1)
  - [ ] 建立 `Configuration/CoordinatorConfig.cs` 配置模型
  - [ ] 定義服務定義、健康檢查和監控參數的資料結構
  - [ ] 建立 `coord.yml` 範本檔案格式規範
  - [ ] 實作配置模型驗證屬性和約束條件

- [ ] 實作 YAML 解析和驗證系統 (AC: 2)
  - [ ] 整合 YamlDotNet 套件進行 YAML 解析
  - [ ] 建立 `Configuration/ConfigurationService.cs` 配置載入服務
  - [ ] 實作配置檔案格式驗證和錯誤報告
  - [ ] 建立配置相容性檢查和版本遷移機制

- [ ] 實作環境變數替換機制 (AC: 3)
  - [ ] 建立 `Configuration/VariableResolver.cs` 變數解析器
  - [ ] 支援 `{{variable}}` 和 `{{section.key}}` 語法解析
  - [ ] 實作環境變數、系統變數和自訂變數的階層式查詢
  - [ ] 建立變數替換的安全機制，避免敏感資訊洩漏

- [ ] 實作配置熱重載功能 (AC: 4)
  - [ ] 建立 `Configuration/ConfigurationWatcher.cs` 檔案監控服務
  - [ ] 實作配置變更檢測和差異分析
  - [ ] 建立安全的配置套用機制，避免無效配置導致服務中斷
  - [ ] 實作配置回滾機制，支援配置錯誤時自動恢復

## Dev Notes

### Previous Story Insights
基於 Story 3.1 和 3.2 已建立的 gRPC 服務和進程管理，本 Story 將提供統一的配置管理系統來管理所有服務的設定。

### YAML 配置架構設計
基於簡化運維和統一管理的原則設計配置系統：

**核心配置模型：**
```csharp
public class CoordinatorConfig
{
    public GlobalConfig Global { get; set; } = new();
    public List<ServiceConfig> Services { get; set; } = new();
    public MonitoringConfig Monitoring { get; set; } = new();
}

public class GlobalConfig
{
    public string Redis { get; set; } = string.Empty;
    public string Database { get; set; } = string.Empty;
    public Dictionary<string, string> Variables { get; set; } = new();
}

public class ServiceConfig
{
    [Required]
    public string Name { get; set; } = string.Empty;
    
    [Required]
    public string Type { get; set; } = string.Empty;
    
    [Required]
    public List<string> Command { get; set; } = new();
    
    public string WorkingDirectory { get; set; } = string.Empty;
    public Dictionary<string, string> Environment { get; set; } = new();
    public HealthCheckConfig HealthCheck { get; set; } = new();
    public List<string> Dependencies { get; set; } = new();
    public int? Replicas { get; set; }
    public int? HealthPort { get; set; }
}

public class HealthCheckConfig
{
    public string Type { get; set; } = "http";  // http, grpc, tcp
    public string Endpoint { get; set; } = string.Empty;
    public int TimeoutMs { get; set; } = 5000;
    public int IntervalMs { get; set; } = 10000;
}

public class MonitoringConfig
{
    public int RecheckIntervalMs { get; set; } = 2000;
    public int UnresponsiveSec { get; set; } = 30;
    public int MaxRestartAttempts { get; set; } = 3;
    public int RestartDelayMs { get; set; } = 5000;
    public bool AutoRestart { get; set; } = true;
}
```

[Source: docs/brownfield-architecture.md#統一配置管理]

**標準 coord.yml 格式：**
```yaml
global:
  redis: "{{REDIS_CONNECTION_STRING}}"
  database: "{{DATABASE_CONNECTION_STRING}}"
  variables:
    workspacePath: "{{WORKSPACE_PATH}}"
    coordinatorEndpoint: "http://localhost:6110"

services:
  - name: "crawler"
    type: "crawler"
    command: ["dotnet", "run", "--project", "StreamNotifyBot.Crawler"]
    workingDirectory: "{{workspacePath}}/StreamNotifyBot.Crawler"
    environment:
      REDIS_CONNECTION: "{{global.redis}}"
      DATABASE_CONNECTION: "{{global.database}}"
    healthCheck:
      type: "http"
      endpoint: "http://localhost:6111/health"
      timeoutMs: 5000
      intervalMs: 10000
    dependencies: []
    
  - name: "discord-shard-{i}"
    type: "discordShard"
    replicas: "{{DISCORD_SHARD_COUNT:3}}"
    command: ["dotnet", "run", "--project", "DiscordStreamNotifyBot", "{shardId}", "{totalShards}"]
    workingDirectory: "{{workspacePath}}/DiscordStreamNotifyBot"
    environment:
      REDIS_CONNECTION: "{{global.redis}}"
      DATABASE_CONNECTION: "{{global.database}}"
      COORDINATOR_ENDPOINT: "{{global.variables.coordinatorEndpoint}}"
    healthCheck:
      type: "grpc"
      timeoutMs: 3000
      intervalMs: 15000
    dependencies: ["crawler"]

monitoring:
  recheckIntervalMs: 2000
  unresponsiveSec: 30
  maxRestartAttempts: 3
  restartDelayMs: 5000
  autoRestart: true
```

[Source: docs/brownfield-architecture.md#coord.yml - 簡化的統一配置]

### YAML 解析和驗證實作
**配置服務實作：**
```csharp
public class ConfigurationService
{
    private readonly ILogger<ConfigurationService> _logger;
    private readonly VariableResolver _variableResolver;
    private CoordinatorConfig _currentConfig;
    
    public async Task<CoordinatorConfig> LoadConfigurationAsync(string configPath)
    {
        try
        {
            var yamlContent = await File.ReadAllTextAsync(configPath);
            
            // 1. 解析 YAML
            var deserializer = new DeserializerBuilder()
                .WithNamingConvention(CamelCaseNamingConvention.Instance)
                .Build();
                
            var rawConfig = deserializer.Deserialize<CoordinatorConfig>(yamlContent);
            
            // 2. 變數替換
            var resolvedConfig = await _variableResolver.ResolveVariablesAsync(rawConfig);
            
            // 3. 配置驗證
            ValidateConfiguration(resolvedConfig);
            
            _currentConfig = resolvedConfig;
            _logger.LogInformation("成功載入配置: {ServiceCount} 個服務", resolvedConfig.Services.Count);
            
            return resolvedConfig;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "載入配置檔案失敗: {ConfigPath}", configPath);
            throw new ConfigurationException($"配置載入失敗: {ex.Message}", ex);
        }
    }
    
    private void ValidateConfiguration(CoordinatorConfig config)
    {
        var context = new ValidationContext(config);
        var results = new List<ValidationResult>();
        
        if (!Validator.TryValidateObject(config, context, results, true))
        {
            var errors = string.Join(", ", results.Select(r => r.ErrorMessage));
            throw new ConfigurationException($"配置驗證失敗: {errors}");
        }
        
        // 自訂業務邏輯驗證
        ValidateServiceDependencies(config.Services);
        ValidateHealthCheckEndpoints(config.Services);
    }
}
```

**YamlDotNet 整合：**
```xml
<PackageReference Include="YamlDotNet" Version="13.7.1" />
<PackageReference Include="System.ComponentModel.Annotations" Version="5.0.0" />
```

[Source: docs/brownfield-prd.md#技術約束和限制]

### 環境變數替換機制
**變數解析器設計：**
```csharp
public class VariableResolver
{
    private readonly ILogger<VariableResolver> _logger;
    private readonly Dictionary<string, string> _systemVariables = new();
    
    public VariableResolver()
    {
        // 載入系統環境變數
        foreach (DictionaryEntry env in Environment.GetEnvironmentVariables())
        {
            _systemVariables[env.Key.ToString()!] = env.Value?.ToString() ?? string.Empty;
        }
    }
    
    public async Task<CoordinatorConfig> ResolveVariablesAsync(CoordinatorConfig config)
    {
        var configJson = JsonSerializer.Serialize(config);
        var resolvedJson = await ResolveVariablesInStringAsync(configJson, config.Global.Variables);
        
        return JsonSerializer.Deserialize<CoordinatorConfig>(resolvedJson)!;
    }
    
    private async Task<string> ResolveVariablesInStringAsync(string input, Dictionary<string, string> customVariables)
    {
        var pattern = @"\{\{([^}]+)\}\}";
        var matches = Regex.Matches(input, pattern);
        
        var result = input;
        foreach (Match match in matches)
        {
            var variablePath = match.Groups[1].Value;
            var resolvedValue = await ResolveVariableValueAsync(variablePath, customVariables);
            result = result.Replace(match.Value, resolvedValue);
        }
        
        return result;
    }
    
    private async Task<string> ResolveVariableValueAsync(string variablePath, Dictionary<string, string> customVariables)
    {
        // 1. 檢查預設值語法 {{VAR:default}}
        var parts = variablePath.Split(':');
        var varName = parts[0];
        var defaultValue = parts.Length > 1 ? parts[1] : string.Empty;
        
        // 2. 嘗試從不同來源解析變數
        string? value = null;
        
        // 2.1 自訂變數（優先級最高）
        if (customVariables.TryGetValue(varName, out value))
            return value;
            
        // 2.2 系統環境變數
        if (_systemVariables.TryGetValue(varName, out value))
            return value;
            
        // 2.3 巢狀屬性查詢 (如 global.redis)
        if (varName.Contains('.'))
        {
            value = await ResolveNestedPropertyAsync(varName, customVariables);
            if (!string.IsNullOrEmpty(value))
                return value;
        }
        
        // 2.4 使用預設值
        if (!string.IsNullOrEmpty(defaultValue))
        {
            _logger.LogWarning("使用預設值: {Variable} = {Default}", varName, defaultValue);
            return defaultValue;
        }
        
        throw new ConfigurationException($"無法解析變數: {varName}");
    }
}
```

**支援的變數語法：**
- `{{VARIABLE}}` - 環境變數
- `{{VARIABLE:default}}` - 帶預設值的環境變數
- `{{global.redis}}` - 巢狀屬性引用
- `{{workspacePath}}/StreamNotifyBot.Crawler` - 路徑組合

[Source: docs/brownfield-prd.md#CR4 配置管理相容性]

### 配置熱重載系統
**檔案監控服務：**
```csharp
public class ConfigurationWatcher : BackgroundService
{
    private readonly ConfigurationService _configService;
    private readonly ProcessManager _processManager;
    private readonly ILogger<ConfigurationWatcher> _logger;
    private readonly FileSystemWatcher _watcher;
    private readonly SemaphoreSlim _reloadSemaphore = new(1, 1);
    
    public ConfigurationWatcher(
        ConfigurationService configService,
        ProcessManager processManager,
        IOptions<CoordinatorOptions> options)
    {
        _configService = configService;
        _processManager = processManager;
        
        var configPath = Path.GetDirectoryName(options.Value.ConfigFilePath)!;
        var configFileName = Path.GetFileName(options.Value.ConfigFilePath);
        
        _watcher = new FileSystemWatcher(configPath, configFileName)
        {
            NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.Size,
            EnableRaisingEvents = true
        };
        
        _watcher.Changed += OnConfigFileChanged;
    }
    
    private async void OnConfigFileChanged(object sender, FileSystemEventArgs e)
    {
        if (!await _reloadSemaphore.WaitAsync(1000))
        {
            _logger.LogWarning("配置重載已在進行中，跳過此次變更");
            return;
        }
        
        try
        {
            // 等待檔案寫入完成
            await Task.Delay(500);
            
            _logger.LogInformation("檢測到配置檔案變更，開始重新載入: {Path}", e.FullPath);
            
            // 載入新配置
            var newConfig = await _configService.LoadConfigurationAsync(e.FullPath);
            
            // 比較配置差異
            var changes = await AnalyzeConfigurationChangesAsync(newConfig);
            
            if (changes.RequiresServiceRestart)
            {
                _logger.LogWarning("配置變更需要重啟服務: {Changes}", 
                    string.Join(", ", changes.AffectedServices));
                await _processManager.ApplyConfigurationChangesAsync(changes);
            }
            else
            {
                _logger.LogInformation("成功套用配置熱重載");
                await _processManager.ApplyRuntimeConfigurationAsync(newConfig);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "配置熱重載失敗，保持原有配置");
        }
        finally
        {
            _reloadSemaphore.Release();
        }
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            // 定期驗證配置一致性
            await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);
        }
    }
}

public class ConfigurationChange
{
    public bool RequiresServiceRestart { get; set; }
    public List<string> AffectedServices { get; set; } = new();
    public List<string> ModifiedSettings { get; set; } = new();
}
```

[Source: docs/brownfield-prd.md#NFR6 部署簡化]

### Project Structure
本 Story 將在現有 Coordinator 專案中新增配置管理功能：
```
StreamNotifyBot.Coordinator/
├── Configuration/
│   ├── CoordinatorConfig.cs        # 本 Story 新增
│   ├── ConfigurationService.cs     # 本 Story 新增  
│   ├── VariableResolver.cs         # 本 Story 新增
│   ├── ConfigurationWatcher.cs     # 本 Story 新增
│   └── ConfigurationException.cs   # 本 Story 新增
├── Services/
│   ├── ProcessManager.cs           # 需修改以支援配置
│   └── ...（其他現有服務）
├── coord.yml                       # 本 Story 新增
└── coord.example.yml               # 本 Story 新增
```

[Source: docs/brownfield-architecture.md#實際技術堆疊]

### 配置檔案範例和文件
**coord.example.yml 範本：**
```yaml
# Discord Stream Notify Bot Coordinator 配置範例
# 複製此檔案為 coord.yml 並修改相應設定

global:
  # Redis 連線字串，支援環境變數替換
  redis: "{{REDIS_CONNECTION_STRING:localhost:6379}}"
  
  # 資料庫連線字串
  database: "{{DATABASE_CONNECTION_STRING}}"
  
  # 自訂變數定義
  variables:
    workspacePath: "{{WORKSPACE_PATH:/app}}"
    coordinatorEndpoint: "http://localhost:6110"
    discordBotToken: "{{DISCORD_BOT_TOKEN}}"

services:
  # Crawler 服務配置
  - name: "crawler"
    type: "crawler"
    command: ["dotnet", "run", "--project", "StreamNotifyBot.Crawler"]
    workingDirectory: "{{workspacePath}}/StreamNotifyBot.Crawler"
    environment:
      REDIS_CONNECTION: "{{global.redis}}"
      DATABASE_CONNECTION: "{{global.database}}"
      LOG_LEVEL: "{{LOG_LEVEL:Information}}"
    healthCheck:
      type: "http"
      endpoint: "http://localhost:6111/health"
      timeoutMs: 5000
      intervalMs: 10000
    dependencies: []
    
  # Discord Shard 服務配置
  - name: "discord-shard-{i}"
    type: "discordShard"
    replicas: "{{DISCORD_SHARD_COUNT:1}}"
    command: ["dotnet", "run", "--project", "DiscordStreamNotifyBot", "{shardId}", "{totalShards}"]
    workingDirectory: "{{workspacePath}}/DiscordStreamNotifyBot"
    environment:
      REDIS_CONNECTION: "{{global.redis}}"
      DATABASE_CONNECTION: "{{global.database}}"
      COORDINATOR_ENDPOINT: "{{global.variables.coordinatorEndpoint}}"
      DISCORD_BOT_TOKEN: "{{global.variables.discordBotToken}}"
    healthCheck:
      type: "grpc"
      timeoutMs: 3000
      intervalMs: 15000
    dependencies: ["crawler"]

# 監控和故障處理設定
monitoring:
  recheckIntervalMs: 2000      # 健康檢查間隔
  unresponsiveSec: 30          # 服務無回應判定時間
  maxRestartAttempts: 3        # 最大重啟次數
  restartDelayMs: 5000         # 重啟延遲時間
  autoRestart: true            # 自動重啟開關
```

**配置驗證規則文件：**
```markdown
# coord.yml 配置驗證規則

## 必要欄位
- global.redis: Redis 連線字串
- global.database: 資料庫連線字串  
- services: 至少包含一個 crawler 類型服務

## 服務配置規則
- name: 服務名稱必須唯一
- type: 必須是 "crawler" 或 "discordShard"
- command: 必須是有效的指令陣列
- dependencies: 引用的服務必須存在

## 健康檢查規則
- type 為 "http" 時必須提供 endpoint
- timeoutMs 必須 > 0 且 < 60000
- intervalMs 必須 >= timeoutMs

## 變數替換規則
- 支援巢狀引用但不能循環依賴
- 環境變數不存在且無預設值時會拋出例外
- 敏感變數（包含 token, password, secret）會被遮罩記錄
```

[Source: docs/brownfield-prd.md#CR4 配置管理相容性]

### 與現有系統整合
**ProcessManager 整合：**
```csharp
public class ProcessManager
{
    public async Task ApplyConfigurationAsync(CoordinatorConfig newConfig)
    {
        _logger.LogInformation("開始套用新配置");
        
        // 1. 比較服務配置差異
        var currentServices = _processes.Keys.ToList();
        var newServices = newConfig.Services.Select(s => s.Name).ToList();
        
        var servicesToRemove = currentServices.Except(newServices).ToList();
        var servicesToAdd = newServices.Except(currentServices).ToList();
        var servicesToUpdate = currentServices.Intersect(newServices).ToList();
        
        // 2. 停止不再需要的服務
        foreach (var serviceId in servicesToRemove)
        {
            await StopServiceAsync(serviceId);
        }
        
        // 3. 更新現有服務（如果配置有變更）
        foreach (var serviceId in servicesToUpdate)
        {
            var newServiceConfig = newConfig.Services.First(s => s.Name == serviceId);
            var hasChanges = await CheckServiceConfigurationChangesAsync(serviceId, newServiceConfig);
            
            if (hasChanges)
            {
                await RestartServiceAsync(serviceId);
            }
        }
        
        // 4. 啟動新服務
        foreach (var serviceId in servicesToAdd)
        {
            var serviceConfig = newConfig.Services.First(s => s.Name == serviceId);
            await StartServiceAsync(serviceConfig);
        }
        
        _logger.LogInformation("配置套用完成");
    }
}
```

**appsettings.json 整合：**
```json
{
  "Coordinator": {
    "ConfigFilePath": "coord.yml",
    "EnableConfigWatcher": true,
    "ConfigReloadDelayMs": 500
  },
  "Logging": {
    "LogLevel": {
      "StreamNotifyBot.Coordinator.Configuration": "Debug"
    }
  }
}
```

[Source: docs/brownfield-architecture.md#技術堆疊]

### Testing

**單元測試需求：**
- YAML 解析和配置模型驗證測試
- 環境變數替換機制測試  
- 配置差異分析和變更檢測測試
- 錯誤處理和例外情況測試

**整合測試需求：**
- 完整配置載入流程測試
- 配置熱重載功能測試
- 變數替換在不同環境下的行為測試

**測試工具和框架：**
- xUnit 作為測試框架
- FluentAssertions 用於複雜物件比較
- Microsoft.Extensions.Configuration.Testing 用於配置測試
- 自訂 TestConfigurationProvider 提供測試配置

**測試配置範例：**
```yaml
# test-coord.yml
global:
  redis: "{{TEST_REDIS:localhost:6379}}"
  database: "{{TEST_DATABASE:InMemory}}"
  
services:
  - name: "test-service"
    type: "crawler"
    command: ["echo", "test"]
    healthCheck:
      type: "http"
      endpoint: "http://localhost:6111/health"

monitoring:
  recheckIntervalMs: 100
  unresponsiveSec: 1
  maxRestartAttempts: 1
```

[Source: docs/brownfield-architecture.md#測試策略]

### 安全和穩定性考量
- **敏感資訊處理**：環境變數中的 token、password 等關鍵字會被遮罩記錄
- **配置驗證**：載入前進行完整驗證，避免無效配置導致服務中斷
- **原子性更新**：配置變更採用原子性操作，失敗時自動回滾
- **權限控制**：配置檔案需要適當的檔案系統權限保護
- **循環依賴檢測**：防止服務依賴關係形成循環
- **資源限制**：防止配置載入消耗過多系統資源

[Source: docs/brownfield-prd.md#技術約束和限制]

### 技術約束和限制
- 使用 YamlDotNet 套件，支援 .NET 8.0
- 配置檔案大小建議不超過 1MB，避免解析效能問題
- 熱重載延遲設定需平衡檔案 I/O 和回應速度
- 環境變數替換不支援複雜運算，僅支援簡單字串替換
- 巢狀變數引用深度限制為 5 層，防止無限遞迴

[Source: docs/brownfield-prd.md#技術約束和限制]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | 建立 YAML 配置管理系統故事 | Scrum Master |
