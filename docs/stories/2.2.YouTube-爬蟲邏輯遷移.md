# Story 2.2: YouTube 爬蟲邏輯遷移

## Status
Draft

## Story
**As a** 系統架構師,
**I want** 將現有 YouTube 相關爬蟲邏輯完整遷移至 Crawler 服務,
**so that** 實現 YouTube 監控功能的獨立部署並支援 API 配額管理和 Webhook 處理

## Acceptance Criteria

1. [ ] 建立 `PlatformMonitors/YoutubeMonitor.cs` 包含所有 YouTube API 邏輯
   - 遷移直播狀態檢測邏輯
   - 遷移影片資訊獲取功能
   - 遷移頻道資訊管理
2. [ ] 遷移 YouTube Data API v3 配額管理機制
   - API 配額計數器
   - 多 API 金鑰輪替
   - 配額超限處理和警告
3. [ ] 整合外部 Backend 服務和 PubSub 訂閱管理
   - 依賴外部 Backend 服務處理 HTTP Webhook 端點
   - 遷移 PubSubHubbub 訂閱管理邏輯
   - 監聽外部 Backend 的 Redis PubSub 通知
4. [ ] 實作 YouTube 直播狀態檢測和變化偵測
   - 定時輪詢機制
   - 狀態變化比較邏輯
   - 批量處理多個頻道
5. [ ] 建立 YouTube API 錯誤處理和重試機制
   - API 呼叫失敗重試
   - Rate Limiting 處理
   - 異常狀況日誌記錄
6. [ ] 實作事件廣播機制
   - 直播開始/結束事件發送
   - 與外部錄影工具相容的事件格式
   - 批量事件合併和發送

## Tasks / Subtasks

- [ ] Task 1: 建立 YouTube 平台監控器基礎架構 (AC: 1)
  - [ ] 建立 `PlatformMonitors/YoutubeMonitor.cs` 實作 `IPlatformMonitor` 介面
  - [ ] 建立 YouTube 服務類別繼承結構
  - [ ] 實作監控器啟動和停止邏輯
  - [ ] 建立 YouTube 特定的配置模型
  - [ ] 設定依賴注入註冊

- [ ] Task 2: 遷移 YouTube API 核心功能 (AC: 1)
  - [ ] 從 `SharedService/Youtube/YoutubeStreamService.cs` 遷移核心 API 方法：
    - `GetVideoAsync(string videoId)` - 取得影片詳細資訊
    - `GetChannelIdAsync(string channelUrl)` - 頻道 URL 解析
    - `GetChannelTitle(string channelId)` - 頻道標題獲取
    - `GetChannelTitle(IEnumerable<string> channelId)` - 批量頻道資訊
  - [ ] 遷移 YouTube API 服務初始化邏輯
  - [ ] 保持 API 方法簽章和行為一致性

- [ ] Task 3: 實作 API 配額管理系統 (AC: 2)
  - [ ] 建立 `Services/YouTubeQuotaManager.cs` 配額管理器
  - [ ] 實作 API 配額計數器和追蹤：
    - 每次 API 調用記錄配額消耗
    - 日配額限制檢查和警告
    - 配額重置機制 (每日午夜 UTC)
  - [ ] 實作多 API 金鑰輪替機制：
    - 支援多組 YouTube API 金鑰配置
    - 自動切換至可用的 API 金鑰
    - 金鑰配額狀態管理
  - [ ] 實作配額超限處理：
    - 配額不足時暫停 API 調用
    - 記錄配額超限事件
    - 提供配額狀態查詢介面

- [ ] Task 4: 整合外部 Webhook Backend 和 PubSub 訂閱管理 (AC: 3)
  - [ ] 整合現有的外部 Backend 服務 (Discord-Stream-Bot-Backend)
    - 外部 Backend 已處理 `/NotificationCallback` HTTP 端點
    - 外部 Backend 已處理 Hub 驗證和 XML 解析
    - Crawler 服務專注於 Redis PubSub 事件處理
  - [ ] 遷移 PubSubHubbub 訂閱管理功能：
    - `PostSubscribeRequestAsync()` 方法遷移到 Crawler 服務
    - 頻道訂閱和取消訂閱邏輯
    - 訂閱狀態追蹤機制
    - 定期重新訂閱機制 (subscribePubSub Timer)
  - [ ] 建立 `Models/YoutubePubSubNotification.cs` 通知模型
  - [ ] 監聽外部 Backend 發送的 Redis PubSub 事件

- [ ] Task 5: 實作定時監控和狀態檢測系統 (AC: 4)
  - [ ] 建立定時器管理系統替換現有 Timer：
    - `holoSchedule` -> Holo 排程監控
    - `nijisanjiSchedule` -> 彩虹社排程監控  
    - `otherSchedule` -> 其他頻道排程監控
    - `checkScheduleTime` -> 排程時間檢查
    - `channelTitleCheckTimer` -> 頻道標題更新
  - [ ] 實作直播狀態變化檢測：
    - 比較前後狀態差異
    - 識別直播開始、結束、時間變更
    - 處理私人化或刪除的直播
  - [ ] 實作批量處理機制：
    - 批量 API 調用減少配額消耗
    - 批量狀態更新和事件發送
    - 處理大量頻道的效能優化

- [ ] Task 6: 建立錯誤處理和重試機制 (AC: 5)
  - [ ] 實作 YouTube API 錯誤分類處理：
    - HTTP 429 (配額超限) 處理
    - HTTP 403 (權限錯誤) 處理
    - HTTP 404 (資源不存在) 處理
    - 網路連接錯誤處理
  - [ ] 建立重試策略系統：
    - 指數退避重試算法
    - 重試次數限制 (預設 3 次)
    - 重試間隔配置
  - [ ] 實作詳細錯誤日誌記錄：
    - API 調用失敗詳細記錄
    - 錯誤類型統計和分析
    - 異常狀況告警機制

- [ ] Task 7: 實作事件廣播和 Redis 整合 (AC: 6)
  - [ ] 建立事件發送服務 `Services/YouTubeEventService.cs`
  - [ ] 實作 Redis PubSub 事件發送：
    - 錄影工具事件: `youtube.record` (videoId) - 直播開始錄影請求
    - Discord Shard 批量事件: `streams.online`, `streams.offline`
    - 服務檢測事件: `youtube.test` - Crawler 啟動時檢測錄影工具
  - [ ] 保持與外部錄影工具的相容性：
    - 維持現有事件格式和資料結構
    - 確保事件資料完整性
  - [ ] 實作批量事件合併和發送：
    - 短時間內多個事件合併
    - 減少 Redis PubSub 負載
    - 提供即時和批量模式選項

- [ ] Task 8: 實作監聽 Discord Shard 追蹤請求 (AC: 6)
  - [ ] 建立追蹤管理服務 `Services/YouTubeTrackingManager.cs`
  - [ ] 實作 Redis PubSub 事件監聽：
    - 監聽 `stream.follow` 事件
    - 監聽 `stream.unfollow` 事件
    - 解析追蹤請求資料格式
  - [ ] 建立動態追蹤目標管理：
    - 維護全域追蹤計數器
    - 新增/移除監控目標
    - 當沒有 Guild 追蹤時停止監控
  - [ ] 實作即時追蹤狀態同步：
    - 追蹤清單變更時立即生效
    - 避免不必要的 API 調用
    - 支援追蹤目標重新啟用

- [ ] Task 9: 整合測試和驗證 (AC: 1-6)
  - [ ] 建立單元測試：
    - YouTube API 方法測試 (使用 Mock)
    - 配額管理系統測試
    - 事件發送邏輯測試
    - 錯誤處理機制測試
  - [ ] 建立整合測試：
    - PubSubHubbub Webhook 處理測試
    - Redis PubSub 通訊測試
    - 完整監控流程端到端測試
  - [ ] 建立效能測試：
    - 大量頻道監控效能測試
    - API 配額使用效率測試
    - 記憶體使用和洩漏檢測

## Dev Notes

### YouTube 服務架構遷移
**[Source: SharedService/Youtube/YoutubeStreamService.cs]**

現有的 `YoutubeStreamService` 是一個複合服務，包含：
- 直播監控邏輯 (多個 Timer)
- API 調用封裝
- PubSubHubbub Webhook 處理
- Redis 事件發送
- 提醒系統
- 會員驗證整合

遷移策略是將核心爬蟲功能提取到獨立的 Crawler 服務，保留 API 調用方法供重用。

### 現有 Timer 系統分析
**[Source: SharedService/Youtube/YoutubeStreamService.cs#47]**

```csharp
private Timer holoSchedule, nijisanjiSchedule, otherSchedule, checkScheduleTime, saveDateBase, subscribePubSub, reScheduleTime;
private Timer channelTitleCheckTimer;
```

這些 Timer 的職責：
- `holoSchedule`: 每 5 分鐘檢查 Holo 成員排程
- `nijisanjiSchedule`: 每 5 分鐘檢查彩虹社排程
- `otherSchedule`: 每 5 分鐘檢查其他頻道排程
- `checkScheduleTime`: 每 15 分鐘檢查排程時間
- `subscribePubSub`: 每 30 分鐘重新訂閱 PubSubHubbub
- `channelTitleCheckTimer`: 每日檢查頻道標題更新

### YouTube API 配額系統設計
**[Source: docs/brownfield-architecture.md#YouTube Data API 配額管理機制]**

```csharp
public class YouTubeQuotaManager
{
    private readonly List<string> _apiKeys;
    private readonly Dictionary<string, int> _dailyQuotaUsage;
    private readonly Dictionary<string, DateTime> _quotaResetTimes;
    private int _currentKeyIndex = 0;
    private const int DAILY_QUOTA_LIMIT = 10000;

    public async Task<YouTubeService> GetAvailableServiceAsync()
    {
        // 檢查當前 API 金鑰配額
        var currentKey = _apiKeys[_currentKeyIndex];
        if (_dailyQuotaUsage[currentKey] >= DAILY_QUOTA_LIMIT)
        {
            // 切換到下一個可用金鑰
            _currentKeyIndex = (_currentKeyIndex + 1) % _apiKeys.Count;
            currentKey = _apiKeys[_currentKeyIndex];
        }

        return new YouTubeService(new BaseClientService.Initializer
        {
            ApplicationName = "DiscordStreamBot",
            ApiKey = currentKey,
        });
    }

    public void RecordQuotaUsage(string apiKey, int cost)
    {
        _dailyQuotaUsage[apiKey] += cost;
        
        // 記錄配額使用情況
        if (_dailyQuotaUsage[apiKey] > DAILY_QUOTA_LIMIT * 0.8)
        {
            Log.Warn($"YouTube API 金鑰 {apiKey[..8]}... 配額使用已達 80%");
        }
    }
}
```

### 外部 Backend 服務整合架構
**[Source: https://github.com/konnokai/Discord-Stream-Bot-Backend]**

系統架構中已有獨立的 Backend 服務處理 YouTube PubSubHubbub Webhook：
- **外部 Backend**: 處理 HTTP 端點 `/NotificationCallback`
- **外部 Backend**: 處理 Hub 驗證流程和 XML 解析
- **Crawler 服務**: 專注於 Redis PubSub 事件監聽和處理

架構流程：
```
YouTube PubSubHubbub → 外部 Backend 服務 → Redis PubSub → Crawler 服務 → 狀態處理
```

不需要在 Crawler 服務中實作 HTTP Webhook 端點，但需要：

```csharp
// Crawler 服務監聽外部 Backend 發送的事件
public class YouTubePubSubListener
{
    public async Task StartListeningAsync()
    {
        // 監聽外部 Backend 發送的 YouTube 通知事件
        await _redis.SubscribeAsync("youtube.pubsub.notification", async (channel, message) =>
        {
            var notification = JsonConvert.DeserializeObject<YoutubePubSubNotification>(message);
            await ProcessPubSubNotificationAsync(notification);
        });
    }
    
    private async Task ProcessPubSubNotificationAsync(YoutubePubSubNotification notification)
    {
        // 處理來自外部 Backend 的 PubSubHubbub 通知
        // 更新影片狀態、發送相關事件等
    }
}
```

### PubSub 訂閱管理邏輯
**[Source: SharedService/Youtube/YoutubeStreamService.cs#982-1000]**

訂閱管理功能仍需要在 Crawler 服務中實作，因為需要動態管理追蹤目標：

```csharp
// 現有訂閱邏輯 - 需要遷移到 Crawler 服務
public class YouTubePubSubSubscriptionManager
{
    public async Task<bool> PostSubscribeRequestAsync(string channelId, bool subscribe = true)
    {
        var request = new HttpRequestMessage(HttpMethod.Post, "https://pubsubhubbub.appspot.com/subscribe");
        var content = new FormUrlEncodedContent(new Dictionary<string, string>()
        {
            { "hub.mode", subscribe ? "subscribe" : "unsubscribe" },
            { "hub.topic", $"https://www.youtube.com/xml/feeds/videos.xml?channel_id={channelId}" },
            { "hub.callback", $"https://{_apiServerUrl}/NotificationCallback" }, // 指向外部 Backend
        });
        
        request.Content = content;
        var response = await _httpClient.SendAsync(request);
        return response.IsSuccessStatusCode;
    }
}
```

新的 Crawler 服務架構中，HTTP 端點處理交給外部 Backend，專注於 Redis PubSub：

```csharp
// Crawler 服務中的 PubSub 事件監聽
public class YouTubeEventProcessor
{
    public async Task StartAsync()
    {
        // 監聽外部 Backend 發送的 PubSubHubbub 通知
        await _redis.SubscribeAsync("youtube.pubsub.notification", ProcessPubSubNotification);
    }
    
    private async Task ProcessPubSubNotification(RedisChannel channel, RedisValue message)
    {
        try
        {
            var notification = JsonConvert.DeserializeObject<YoutubePubSubNotification>(message);
            
            // 處理影片狀態變化
            await ProcessVideoStatusChange(notification);
            
            // 發送相關事件給 Discord Shard 和錄影工具
            await BroadcastStreamEvents(notification);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to process YouTube PubSub notification");
        }
    }
}
```

### 事件廣播格式相容性
**[Source: SharedService/Youtube/YoutubeStreamService.cs#77-218 + StreamRecordTools 相容性]**

新的事件廣播架構支援雙向通訊：

```csharp
// Crawler 服務發送事件給錄影工具和 Discord Shard
public class YouTubeEventBroadcaster
{
    public async Task BroadcastStreamStatusChange(string videoId, bool isOnline)
    {
        if (isOnline)
        {
            // 發送給錄影工具的錄影請求
            await _redis.PublishAsync("youtube.record", videoId);
            
            // 發送給 Discord Shard 的批量通知
            var streamData = new { VideoId = videoId, Platform = "youtube" };
            await _redis.PublishAsync("streams.online", JsonConvert.SerializeObject(new[] { streamData }));
        }
        else
        {
            // 發送給 Discord Shard 的關台通知
            var streamData = new { VideoId = videoId, Platform = "youtube" };
            await _redis.PublishAsync("streams.offline", JsonConvert.SerializeObject(new[] { streamData }));
        }
    }
}

新的 Crawler 服務需要發送相同格式的事件：

```csharp
// 在 Crawler 服務中發送事件
public class YouTubeEventService
{
    public async Task PublishStreamStatusChange(string videoId, bool isOnline)
    {
        // 發送給 Discord Shard 的批量事件
        var batchEvent = isOnline ? "streams.online" : "streams.offline";
        var streamData = new { VideoId = videoId, Platform = "youtube" };
        await _redis.PublishAsync(batchEvent, JsonConvert.SerializeObject(new[] { streamData }));
        
        // 發送給錄影工具的錄影請求（僅在直播開始時）
        if (isOnline)
        {
            await _redis.PublishAsync("youtube.record", videoId);
        }
    }
    
    public async Task CheckRecordingToolAvailability()
    {
        // Crawler 啟動時檢測錄影工具是否運行
        var subscriberCount = await _redis.PublishAsync("youtube.test", "");
        if (subscriberCount > 0)
        {
            _logger.LogInfo("錄影工具已檢測到，可以正常錄影");
        }
        else
        {
            _logger.LogWarn("未檢測到錄影工具，請確認錄影工具是否已啟動");
        }
    }
}
```

### 平台監控介面實作
**[Source: docs/brownfield-architecture.md#平台監控介面設計]**

```csharp
public class YoutubeMonitor : IPlatformMonitor
{
    private readonly YouTubeQuotaManager _quotaManager;
    private readonly YouTubeEventService _eventService;
    private readonly YouTubeTrackingManager _trackingManager;
    private readonly ILogger<YoutubeMonitor> _logger;
    
    public string PlatformName => "YouTube";
    public event EventHandler<StreamStatusChangedEventArgs> StreamStatusChanged;

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Starting YouTube monitor...");
        
        // 啟動定時監控任務
        _ = Task.Run(() => HoloScheduleMonitorAsync(cancellationToken), cancellationToken);
        _ = Task.Run(() => NijisanjiScheduleMonitorAsync(cancellationToken), cancellationToken);
        _ = Task.Run(() => OtherChannelMonitorAsync(cancellationToken), cancellationToken);
        
        // 啟動 PubSubHubbub 訂閱維護
        _ = Task.Run(() => MaintainPubSubSubscriptionsAsync(cancellationToken), cancellationToken);
        
        _logger.LogInformation("YouTube monitor started");
    }

    public async Task StopAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Stopping YouTube monitor...");
        // 優雅停止所有監控任務
        _logger.LogInformation("YouTube monitor stopped");
    }

    public async Task<PlatformMonitorStatus> GetStatusAsync()
    {
        return new PlatformMonitorStatus
        {
            PlatformName = PlatformName,
            IsHealthy = await CheckHealthAsync(),
            MonitoredStreamsCount = await _trackingManager.GetTrackedStreamCountAsync(),
            LastUpdateTime = DateTime.UtcNow,
            Metadata = new Dictionary<string, object>
            {
                ["quota_usage"] = await _quotaManager.GetQuotaUsageAsync(),
                ["active_subscriptions"] = await GetActiveSubscriptionCountAsync()
            }
        };
    }
}
```

### 資料庫整合和狀態管理
**[Source: docs/brownfield-architecture.md#資料庫架構保持不變]**

Crawler 服務繼續使用現有的資料庫結構：

```csharp
public class YouTubeDataService
{
    private readonly MainDbContext _dbContext;

    public async Task<List<FollowedStream>> GetTrackedYouTubeChannelsAsync()
    {
        return await _dbContext.FollowedStreams
            .Where(fs => fs.Platform == "youtube")
            .ToListAsync();
    }

    public async Task UpdateVideoDataAsync(VideoData videoData)
    {
        var existingVideo = await _dbContext.Videos
            .FirstOrDefaultAsync(v => v.VideoId == videoData.VideoId);
            
        if (existingVideo == null)
        {
            _dbContext.Videos.Add(videoData);
        }
        else
        {
            // 更新現有影片資料
            existingVideo.Title = videoData.Title;
            existingVideo.Status = videoData.Status;
            // ... 更新其他欄位
        }
        
        await _dbContext.SaveChangesAsync();
    }
}
```

### 錯誤處理和重試策略
**[Source: docs/brownfield-architecture.md#API 錯誤處理和重試機制]**

```csharp
public class YouTubeApiErrorHandler
{
    private readonly ILogger<YouTubeApiErrorHandler> _logger;
    private const int MAX_RETRY_ATTEMPTS = 3;

    public async Task<T> ExecuteWithRetryAsync<T>(Func<Task<T>> apiCall)
    {
        var attempt = 0;
        while (attempt < MAX_RETRY_ATTEMPTS)
        {
            try
            {
                return await apiCall();
            }
            catch (GoogleApiException ex) when (ex.HttpStatusCode == HttpStatusCode.TooManyRequests)
            {
                // 429 錯誤 - 配額超限
                _logger.LogWarning($"YouTube API quota exceeded, attempt {attempt + 1}");
                if (attempt == MAX_RETRY_ATTEMPTS - 1) throw;
                
                // 指數退避
                var delay = TimeSpan.FromSeconds(Math.Pow(2, attempt) * 30);
                await Task.Delay(delay);
            }
            catch (GoogleApiException ex) when (ex.HttpStatusCode == HttpStatusCode.Forbidden)
            {
                // 403 錯誤 - 權限問題，不重試
                _logger.LogError($"YouTube API access forbidden: {ex.Message}");
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"YouTube API call failed, attempt {attempt + 1}");
                if (attempt == MAX_RETRY_ATTEMPTS - 1) throw;
                
                var delay = TimeSpan.FromSeconds(Math.Pow(2, attempt) * 5);
                await Task.Delay(delay);
            }
            
            attempt++;
        }
        
        throw new InvalidOperationException("Max retry attempts exceeded");
    }
}
```

### 配置管理結構
**[Source: docs/brownfield-architecture.md#配置管理簡化]**

```csharp
public class YouTubeConfig
{
    public List<string> ApiKeys { get; set; } = new();
    public int DailyQuotaLimit { get; set; } = 10000;
    public int MonitorIntervalMinutes { get; set; } = 5;
    public string WebhookCallbackUrl { get; set; } = "";
    public bool EnablePubSubHubbub { get; set; } = true;
    public int MaxRetryAttempts { get; set; } = 3;
}
```

### Testing

**單元測試要求**:
- YouTube API 方法測試 (Mock GoogleApiException)
- 配額管理系統測試 (API 金鑰輪替)
- 事件發送邏輯測試 (Redis PubSub Mock)
- 錯誤處理和重試機制測試

**整合測試要求**:
- 外部 Backend 與 Crawler 服務的 PubSub 通訊測試
- Redis PubSub 雙向通訊測試
- 資料庫操作和 Entity Framework 測試
- 完整監控流程測試

**手動測試驗證**:
1. 驗證 YouTube 頻道監控正常運作
2. 測試 API 配額管理和金鑰輪替
3. 驗證外部 Backend 與 Crawler 的 PubSub 通訊
4. 測試 PubSubHubbub 訂閱管理功能
5. 測試直播狀態變化檢測和事件發送
6. 驗證與外部錄影工具的事件相容性

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | Story 初始建立 | Scrum Master |

## Dev Agent Record

_此區段由開發代理在實作期間填寫_

### Agent Model Used

_待開發代理填寫_

### Debug Log References

_待開發代理填寫_

### Completion Notes List

_待開發代理填寫_

### File List

_待開發代理填寫_

## QA Results

_此區段由 QA 代理在完成故事實作的 QA 審查後填寫_
