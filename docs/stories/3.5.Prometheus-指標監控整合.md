# Story 3.5: Prometheus 指標監控整合

## Status
Draft

## Story
**As a** 系統管理員,
**I want** 在 Coordinator 服務中整合 Prometheus 指標暴露，收集詳細的系統監控數據,
**so that** 能夠透過 Prometheus/Grafana 等標準監控工具進行深度系統監控和告警

## Acceptance Criteria

1. [ ] 整合 Prometheus 指標收集中介軟體
   - 使用 `prometheus-net.AspNetCore` 套件
   - 暴露 `/metrics` 端點
   - 支援標準 Prometheus 指標格式
2. [ ] 實作系統層級指標收集
   - 服務運行時間 (uptime)
   - CPU 和記憶體使用率
   - GC 統計資訊
   - HTTP 請求統計 (gRPC 調用)
3. [ ] 實作服務管理指標
   - 託管服務數量和狀態
   - 服務重啟次數和原因
   - 心跳接收統計
   - 服務健康檢查結果
4. [ ] 實作 Discord 生態系統指標
   - 總 Shard 數量和狀態
   - Guild 總數和每 Shard 分佈
   - 各 Shard 連接延遲
   - Discord API 調用統計
5. [ ] 實作 Crawler 服務指標
   - 監控的直播數量 (按平台分類)
   - API 配額使用情況 (YouTube/Twitch/Twitter/TwitCasting)
   - 事件廣播統計 (成功/失敗)
   - 會員驗證統計
6. [ ] 建立 Grafana 儀表板範例
   - 系統概覽儀表板
   - 服務詳細監控儀表板
   - 告警規則範例
   - 部署和配置說明

## Tasks / Subtasks

- [ ] Task 1: 整合 Prometheus 基礎架構 (AC: 1)
  - [ ] 安裝 `prometheus-net.AspNetCore` NuGet 套件
  - [ ] 在 `Program.cs` 中配置 Prometheus 中介軟體
  - [ ] 暴露 `/metrics` HTTP 端點
  - [ ] 配置指標收集器和註冊表
  - [ ] 實作基本的 ASP.NET Core 指標 (HTTP 請求、回應時間)

- [ ] Task 2: 建立系統層級指標收集 (AC: 2)
  - [ ] 建立 `Metrics/SystemMetricsCollector.cs` 收集系統指標：
    - `coordinator_uptime_seconds` - 服務運行時間
    - `coordinator_memory_usage_bytes` - 記憶體使用量
    - `coordinator_gc_collections_total` - GC 收集次數
    - `coordinator_cpu_usage_percent` - CPU 使用率
  - [ ] 實作定期系統指標更新 (每 30 秒)
  - [ ] 整合 .NET 原生效能計數器
  - [ ] 建立指標標籤管理 (服務版本、環境等)

- [ ] Task 3: 實作服務管理指標 (AC: 3)
  - [ ] 建立 `Metrics/ServiceManagementMetrics.cs` 收集管理指標：
    - `coordinator_managed_services_total` - 託管服務總數
    - `coordinator_service_status` - 服務狀態 (healthy/unhealthy/unknown)
    - `coordinator_service_restarts_total` - 服務重啟次數
    - `coordinator_heartbeat_received_total` - 心跳接收統計
    - `coordinator_health_check_duration_seconds` - 健康檢查執行時間
  - [ ] 整合服務狀態變化事件觸發指標更新
  - [ ] 實作服務標籤 (service_name, service_type, shard_id)
  - [ ] 建立服務生命週期事件記錄

- [ ] Task 4: 實作 Discord 生態系統指標 (AC: 4)
  - [ ] 建立 `Metrics/DiscordMetricsCollector.cs` 收集 Discord 指標：
    - `discord_shards_total` - 總 Shard 數量
    - `discord_shard_status` - Shard 連接狀態
    - `discord_guilds_total` - Guild 總數 (按 Shard 分組)
    - `discord_shard_latency_milliseconds` - Shard 延遲
    - `discord_api_calls_total` - Discord API 調用統計
  - [ ] 從心跳資料中提取 Discord 相關指標
  - [ ] 實作 Shard 健康狀態監控
  - [ ] 建立 Discord API 錯誤統計

- [ ] Task 5: 實作 Crawler 服務指標 (AC: 5)
  - [ ] 建立 `Metrics/CrawlerMetricsCollector.cs` 收集 Crawler 指標：
    - `crawler_monitored_streams_total` - 監控直播數量 (按平台標籤)
    - `crawler_api_quota_usage_percent` - API 配額使用率
    - `crawler_api_calls_total` - 外部 API 調用統計
    - `crawler_events_broadcast_total` - 事件廣播統計
    - `crawler_member_verification_total` - 會員驗證統計
  - [ ] 從 Crawler 心跳資料提取業務指標
  - [ ] 實作平台 API 錯誤率監控
  - [ ] 建立追蹤管理操作統計

- [ ] Task 6: 建立進階指標和告警規則 (AC: 3, 4, 5)
  - [ ] 實作複合指標計算：
    - 系統整體健康評分
    - 服務可用性百分比
    - API 錯誤率趨勢
  - [ ] 建立告警條件指標：
    - `coordinator_service_down` - 服務下線告警
    - `coordinator_high_memory_usage` - 高記憶體使用告警
    - `crawler_api_quota_exhausted` - API 配額耗盡告警
  - [ ] 實作指標閾值配置管理
  - [ ] 建立指標歷史趨勢分析

- [ ] Task 7: 建立 Grafana 儀表板和配置 (AC: 6)
  - [ ] 建立 `monitoring/grafana/dashboards/` 資料夾
  - [ ] 建立系統概覽儀表板 `system-overview.json`：
    - 服務狀態總覽
    - 系統資源使用情況
    - 最近 24 小時趨勢
  - [ ] 建立詳細監控儀表板 `detailed-monitoring.json`：
    - 各服務詳細指標
    - Shard 狀態和效能
    - API 配額和調用統計
  - [ ] 建立告警規則 `monitoring/prometheus/alerts.yml`：
    - 服務下線告警
    - 高資源使用告警
    - API 配額告警
  - [ ] 建立部署說明文件 `monitoring/README.md`

- [ ] Task 8: 實作指標配置管理 (AC: 1-6)
  - [ ] 擴展 Coordinator 配置支援 Prometheus 設定：
    ```yaml
    prometheus:
      enabled: true
      endpoint: "/metrics"
      update_interval_seconds: 30
      enable_system_metrics: true
      enable_service_metrics: true
      enable_discord_metrics: true
      enable_crawler_metrics: true
    ```
  - [ ] 實作指標開關控制 (可選擇啟用的指標類型)
  - [ ] 建立指標標籤配置管理
  - [ ] 實作指標收集效能優化選項

- [ ] Task 9: 建立測試和驗證 (AC: 1-6)
  - [ ] 建立 Prometheus 指標收集單元測試
  - [ ] 驗證 `/metrics` 端點回應格式正確性
  - [ ] 測試各類型指標收集的準確性
  - [ ] 建立指標效能測試 (收集開銷)
  - [ ] 驗證 Grafana 儀表板顯示正確性
  - [ ] 測試告警規則觸發機制

## Dev Notes

### Prometheus 整合架構
**[Source: Story 3.1 Coordinator gRPC 服務建立]**

基於已建立的 Coordinator gRPC 服務，整合 Prometheus 指標收集能夠提供標準化的監控能力。

### 技術選型和實作策略

**prometheus-net.AspNetCore 整合**：
```csharp
// Program.cs 中的 Prometheus 配置
using Prometheus;

var builder = WebApplication.CreateBuilder(args);

// 服務註冊
builder.Services.AddGrpc();
builder.Services.AddSingleton<SystemMetricsCollector>();
builder.Services.AddSingleton<ServiceManagementMetrics>();
builder.Services.AddSingleton<DiscordMetricsCollector>();
builder.Services.AddSingleton<CrawlerMetricsCollector>();

var app = builder.Build();

// Prometheus 中介軟體
app.UseHttpMetrics(); // 自動收集 HTTP 指標
app.UseRouting();
app.MapMetrics(); // 暴露 /metrics 端點
app.MapGrpcService<CoordinatorService>();

await app.RunAsync();
```

### 核心指標設計

**系統層級指標實作**：
```csharp
public class SystemMetricsCollector : BackgroundService
{
    private readonly Gauge _uptimeGauge = Metrics
        .CreateGauge("coordinator_uptime_seconds", "Service uptime in seconds");
    
    private readonly Gauge _memoryUsageGauge = Metrics
        .CreateGauge("coordinator_memory_usage_bytes", "Memory usage in bytes");
    
    private readonly Counter _gcCollectionsCounter = Metrics
        .CreateCounter("coordinator_gc_collections_total", "Total GC collections", new[] { "generation" });
    
    private readonly Gauge _cpuUsageGauge = Metrics
        .CreateGauge("coordinator_cpu_usage_percent", "CPU usage percentage");
    
    private readonly DateTime _startTime = DateTime.UtcNow;
    private readonly PerformanceCounter _cpuCounter;
    
    public SystemMetricsCollector()
    {
        _cpuCounter = new PerformanceCounter("Processor", "% Processor Time", "_Total");
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            UpdateSystemMetrics();
            await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken);
        }
    }
    
    private void UpdateSystemMetrics()
    {
        // 運行時間
        _uptimeGauge.Set((DateTime.UtcNow - _startTime).TotalSeconds);
        
        // 記憶體使用
        _memoryUsageGauge.Set(GC.GetTotalMemory(false));
        
        // GC 統計
        for (int gen = 0; gen <= GC.MaxGeneration; gen++)
        {
            _gcCollectionsCounter.WithLabels($"gen{gen}")
                .IncTo(GC.CollectionCount(gen));
        }
        
        // CPU 使用率
        var cpuUsage = _cpuCounter.NextValue();
        _cpuUsageGauge.Set(cpuUsage);
    }
}
```

**服務管理指標實作**：
```csharp
public class ServiceManagementMetrics
{
    private readonly Gauge _managedServicesGauge = Metrics
        .CreateGauge("coordinator_managed_services_total", "Total managed services");
    
    private readonly Gauge _serviceStatusGauge = Metrics
        .CreateGauge("coordinator_service_status", "Service status (1=healthy, 0=unhealthy)", 
            new[] { "service_name", "service_type" });
    
    private readonly Counter _serviceRestartsCounter = Metrics
        .CreateCounter("coordinator_service_restarts_total", "Total service restarts", 
            new[] { "service_name", "reason" });
    
    private readonly Counter _heartbeatCounter = Metrics
        .CreateCounter("coordinator_heartbeat_received_total", "Total heartbeats received", 
            new[] { "service_name" });
    
    private readonly Histogram _healthCheckDuration = Metrics
        .CreateHistogram("coordinator_health_check_duration_seconds", 
            "Health check execution duration", new[] { "service_name" });
    
    public void UpdateServiceCount(int count)
    {
        _managedServicesGauge.Set(count);
    }
    
    public void UpdateServiceStatus(string serviceName, string serviceType, bool isHealthy)
    {
        _serviceStatusGauge.WithLabels(serviceName, serviceType).Set(isHealthy ? 1 : 0);
    }
    
    public void RecordServiceRestart(string serviceName, string reason)
    {
        _serviceRestartsCounter.WithLabels(serviceName, reason).Inc();
    }
    
    public void RecordHeartbeat(string serviceName)
    {
        _heartbeatCounter.WithLabels(serviceName).Inc();
    }
    
    public IDisposable StartHealthCheckTimer(string serviceName)
    {
        return _healthCheckDuration.WithLabels(serviceName).NewTimer();
    }
}
```

**Discord 生態系統指標實作**：
```csharp
public class DiscordMetricsCollector
{
    private readonly Gauge _shardsGauge = Metrics
        .CreateGauge("discord_shards_total", "Total Discord shards");
    
    private readonly Gauge _shardStatusGauge = Metrics
        .CreateGauge("discord_shard_status", "Shard status (1=connected, 0=disconnected)", 
            new[] { "shard_id" });
    
    private readonly Gauge _guildsGauge = Metrics
        .CreateGauge("discord_guilds_total", "Total guilds", new[] { "shard_id" });
    
    private readonly Gauge _shardLatencyGauge = Metrics
        .CreateGauge("discord_shard_latency_milliseconds", "Shard latency in milliseconds", 
            new[] { "shard_id" });
    
    private readonly Counter _apiCallsCounter = Metrics
        .CreateCounter("discord_api_calls_total", "Total Discord API calls", 
            new[] { "shard_id", "method", "status" });
    
    public void UpdateShardMetrics(HeartbeatRequest request)
    {
        if (request.ShardId.HasValue)
        {
            var shardId = request.ShardId.Value.ToString();
            
            // 更新 Shard 狀態
            var isHealthy = request.Status?.Status == "healthy";
            _shardStatusGauge.WithLabels(shardId).Set(isHealthy ? 1 : 0);
            
            // 更新 Guild 數量
            if (request.GuildCount.HasValue)
            {
                _guildsGauge.WithLabels(shardId).Set(request.GuildCount.Value);
            }
            
            // 更新延遲
            var latencyMetric = request.Metrics?.FirstOrDefault(m => m.Name == "shard_latency_ms");
            if (latencyMetric != null && double.TryParse(latencyMetric.Value, out var latency))
            {
                _shardLatencyGauge.WithLabels(shardId).Set(latency);
            }
        }
    }
    
    public void RecordApiCall(string shardId, string method, string status)
    {
        _apiCallsCounter.WithLabels(shardId, method, status).Inc();
    }
}
```

**Crawler 服務指標實作**：
```csharp
public class CrawlerMetricsCollector
{
    private readonly Gauge _monitoredStreamsGauge = Metrics
        .CreateGauge("crawler_monitored_streams_total", "Total monitored streams", 
            new[] { "platform" });
    
    private readonly Gauge _apiQuotaGauge = Metrics
        .CreateGauge("crawler_api_quota_usage_percent", "API quota usage percentage", 
            new[] { "platform" });
    
    private readonly Counter _apiCallsCounter = Metrics
        .CreateCounter("crawler_api_calls_total", "Total API calls", 
            new[] { "platform", "status" });
    
    private readonly Counter _eventsBroadcastCounter = Metrics
        .CreateCounter("crawler_events_broadcast_total", "Total events broadcast", 
            new[] { "event_type", "status" });
    
    private readonly Counter _memberVerificationCounter = Metrics
        .CreateCounter("crawler_member_verification_total", "Total member verifications", 
            new[] { "platform", "result" });
    
    public void UpdateCrawlerMetrics(HeartbeatRequest request)
    {
        if (request.ServiceName == "crawler")
        {
            // 從 Crawler 心跳資料更新指標
            foreach (var metric in request.Metrics ?? Enumerable.Empty<MetricData>())
            {
                switch (metric.Name)
                {
                    case "monitored_streams_youtube":
                        _monitoredStreamsGauge.WithLabels("youtube").Set(double.Parse(metric.Value));
                        break;
                    case "monitored_streams_twitch":
                        _monitoredStreamsGauge.WithLabels("twitch").Set(double.Parse(metric.Value));
                        break;
                    case "api_quota_youtube":
                        _apiQuotaGauge.WithLabels("youtube").Set(double.Parse(metric.Value));
                        break;
                    case "api_quota_twitch":
                        _apiQuotaGauge.WithLabels("twitch").Set(double.Parse(metric.Value));
                        break;
                }
            }
        }
    }
    
    public void RecordApiCall(string platform, string status)
    {
        _apiCallsCounter.WithLabels(platform, status).Inc();
    }
    
    public void RecordEventBroadcast(string eventType, string status)
    {
        _eventsBroadcastCounter.WithLabels(eventType, status).Inc();
    }
    
    public void RecordMemberVerification(string platform, string result)
    {
        _memberVerificationCounter.WithLabels(platform, result).Inc();
    }
}
```

### Grafana 儀表板設計

**系統概覽儀表板結構**：
```json
{
  "dashboard": {
    "title": "Discord Stream Notify Bot - System Overview",
    "panels": [
      {
        "title": "Service Status",
        "type": "stat",
        "targets": [
          {
            "expr": "coordinator_service_status",
            "legendFormat": "{{service_name}}"
          }
        ]
      },
      {
        "title": "System Resources",
        "type": "graph",
        "targets": [
          {
            "expr": "coordinator_memory_usage_bytes / 1024 / 1024",
            "legendFormat": "Memory (MB)"
          },
          {
            "expr": "coordinator_cpu_usage_percent",
            "legendFormat": "CPU (%)"
          }
        ]
      },
      {
        "title": "Discord Shards",
        "type": "table",
        "targets": [
          {
            "expr": "discord_shard_status",
            "format": "table"
          }
        ]
      }
    ]
  }
}
```

**告警規則設計**：
```yaml
# monitoring/prometheus/alerts.yml
groups:
  - name: coordinator
    rules:
      - alert: ServiceDown
        expr: coordinator_service_status == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service {{$labels.service_name}} is down"
          
      - alert: HighMemoryUsage
        expr: coordinator_memory_usage_bytes > 1073741824  # 1GB
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High memory usage: {{$value | humanize}}B"
          
      - alert: APIQuotaExhausted
        expr: crawler_api_quota_usage_percent > 90
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "API quota for {{$labels.platform}} is almost exhausted: {{$value}}%"
```

### 配置管理整合

**coord.yml 配置擴展**：
```yaml
global:
  redis:
    connectionString: "{{REDIS_CONNECTION_STRING:localhost:6379}}"
  database:
    connectionString: "{{DATABASE_CONNECTION_STRING}}"
    
# 新增 Prometheus 配置區塊
prometheus:
  enabled: true
  endpoint: "/metrics"
  port: 6112  # 專用於 metrics 的端口
  update_interval_seconds: 30
  metrics:
    system: true
    service_management: true
    discord: true
    crawler: true
  labels:
    environment: "{{ENVIRONMENT:production}}"
    version: "{{VERSION:unknown}}"

services:
  crawler:
    type: "crawler"
    # ... 其他設定
    
  discordShards:
    type: "discordShard" 
    # ... 其他設定
    
monitoring:
  recheckIntervalMs: 2000
  unresponsiveSec: 30
  maxRestartAttempts: 3
  
# 新增告警配置
alerting:
  discord_webhook: "{{DISCORD_WEBHOOK_URL}}"
  enabled: true
  rules:
    - name: "service_down"
      condition: "coordinator_service_status == 0"
      duration: "1m"
      severity: "critical"
    - name: "high_memory"
      condition: "coordinator_memory_usage_bytes > 1073741824"
      duration: "5m"
      severity: "warning"
```

### 部署和使用說明

**監控設定步驟**：

1. **Prometheus 安裝和配置**：
```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'coordinator'
    static_configs:
      - targets: ['localhost:6112']
    scrape_interval: 30s
    metrics_path: '/metrics'
```

2. **Grafana 儀表板匯入**：
- 將提供的 `monitoring/grafana/dashboards/*.json` 匯入 Grafana
- 配置 Prometheus 作為資料源
- 設定告警通知頻道

3. **告警規則配置**：
```bash
# 將告警規則檔案複製到 Prometheus 配置目錄
cp monitoring/prometheus/alerts.yml /etc/prometheus/
# 重新載入 Prometheus 配置
curl -X POST http://localhost:6112/-/reload
```

### 效能和安全考量

**效能優化**：
- 指標收集間隔可配置（預設 30 秒）
- 支援選擇性啟用指標類型
- 使用高效能的 prometheus-net 函式庫
- 避免在高頻路徑中建立新指標

**安全考量**：
- `/metrics` 端點可配置存取限制
- 支援基本認證保護指標資料
- 敏感資訊不包含在指標標籤中
- 配置環境變數避免硬編碼敏感資料

### Testing

**單元測試要求**：
- 各指標收集器的正確性測試
- 指標標籤和值的驗證測試
- 配置載入和驗證測試
- 指標暴露端點的回應測試

**整合測試要求**：
- 與真實 Prometheus 伺服器的整合測試
- Grafana 儀表板資料顯示測試
- 告警規則觸發和通知測試
- 效能負載測試

**手動測試驗證**：
1. 驗證 `/metrics` 端點回應 Prometheus 格式
2. 測試各類指標在 Grafana 中的顯示
3. 驗證告警規則在異常情況下的觸發
4. 測試指標收集的效能影響
5. 驗證配置熱重載功能
6. 測試不同監控場景的完整性

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-18 | 1.0 | Story 初始建立 | Scrum Master |

## Dev Agent Record

_此區段由開發代理在實作期間填寫_

### Agent Model Used

_待開發代理填寫_

### Debug Log References

_待開發代理填寫_

### Completion Notes List

_待開發代理填寫_

### File List

_待開發代理填寫_

## QA Results

_此區段由 QA 代理在完成故事實作的 QA 審查後填寫_
